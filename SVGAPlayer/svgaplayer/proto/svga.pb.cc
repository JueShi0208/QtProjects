// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: svga.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "svga.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace opensource {
namespace svga {
class MovieParamsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<MovieParams> {
} _MovieParams_default_instance_;
class SpriteEntityDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SpriteEntity> {
} _SpriteEntity_default_instance_;
class AudioEntityDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<AudioEntity> {
} _AudioEntity_default_instance_;
class LayoutDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Layout> {
} _Layout_default_instance_;
class TransformDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Transform> {
} _Transform_default_instance_;
class ShapeEntity_ShapeArgsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ShapeEntity_ShapeArgs> {
} _ShapeEntity_ShapeArgs_default_instance_;
class ShapeEntity_RectArgsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ShapeEntity_RectArgs> {
} _ShapeEntity_RectArgs_default_instance_;
class ShapeEntity_EllipseArgsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ShapeEntity_EllipseArgs> {
} _ShapeEntity_EllipseArgs_default_instance_;
class ShapeEntity_ShapeStyle_RGBAColorDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ShapeEntity_ShapeStyle_RGBAColor> {
} _ShapeEntity_ShapeStyle_RGBAColor_default_instance_;
class ShapeEntity_ShapeStyleDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ShapeEntity_ShapeStyle> {
} _ShapeEntity_ShapeStyle_default_instance_;
class ShapeEntityDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ShapeEntity> {
  public:
  const ::com::opensource::svga::ShapeEntity_ShapeArgs* shape_;
  const ::com::opensource::svga::ShapeEntity_RectArgs* rect_;
  const ::com::opensource::svga::ShapeEntity_EllipseArgs* ellipse_;
} _ShapeEntity_default_instance_;
class FrameEntityDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<FrameEntity> {
} _FrameEntity_default_instance_;
class MovieEntity_ImagesEntryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<MovieEntity::MovieEntity_ImagesEntry> {
} _MovieEntity_ImagesEntry_default_instance_;
class MovieEntityDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<MovieEntity> {
} _MovieEntity_default_instance_;

namespace protobuf_svga_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[14];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[3];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieParams, viewboxwidth_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieParams, viewboxheight_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieParams, fps_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieParams, frames_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpriteEntity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpriteEntity, imagekey_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpriteEntity, frames_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioEntity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioEntity, audiokey_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioEntity, startframe_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioEntity, endframe_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioEntity, starttime_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioEntity, totaltime_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layout, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layout, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layout, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layout, width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Layout, height_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transform, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transform, a_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transform, b_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transform, c_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transform, d_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transform, tx_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Transform, ty_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeArgs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeArgs, d_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_RectArgs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_RectArgs, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_RectArgs, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_RectArgs, width_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_RectArgs, height_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_RectArgs, cornerradius_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_EllipseArgs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_EllipseArgs, x_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_EllipseArgs, y_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_EllipseArgs, radiusx_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_EllipseArgs, radiusy_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle_RGBAColor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle_RGBAColor, r_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle_RGBAColor, g_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle_RGBAColor, b_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle_RGBAColor, a_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, fill_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, stroke_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, strokewidth_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, linecap_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, linejoin_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, miterlimit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, linedashi_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, linedashii_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity_ShapeStyle, linedashiii_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity, _internal_metadata_),
  ~0u,  // no _extensions_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity, type_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ShapeEntity_default_instance_), shape_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ShapeEntity_default_instance_), rect_),
  GOOGLE_PROTOBUF_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ShapeEntity_default_instance_), ellipse_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity, styles_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity, transform_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShapeEntity, args_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameEntity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameEntity, alpha_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameEntity, layout_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameEntity, transform_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameEntity, clippath_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameEntity, shapes_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieEntity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieEntity, version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieEntity, params_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieEntity, images_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieEntity, sprites_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MovieEntity, audios_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(MovieParams)},
  { 9, -1, sizeof(SpriteEntity)},
  { 16, -1, sizeof(AudioEntity)},
  { 26, -1, sizeof(Layout)},
  { 35, -1, sizeof(Transform)},
  { 46, -1, sizeof(ShapeEntity_ShapeArgs)},
  { 52, -1, sizeof(ShapeEntity_RectArgs)},
  { 62, -1, sizeof(ShapeEntity_EllipseArgs)},
  { 71, -1, sizeof(ShapeEntity_ShapeStyle_RGBAColor)},
  { 80, -1, sizeof(ShapeEntity_ShapeStyle)},
  { 94, -1, sizeof(ShapeEntity)},
  { 106, -1, sizeof(FrameEntity)},
  { 116, -1, sizeof(MovieEntity)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_MovieParams_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_SpriteEntity_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_AudioEntity_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Layout_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Transform_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ShapeEntity_ShapeArgs_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ShapeEntity_RectArgs_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ShapeEntity_EllipseArgs_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ShapeEntity_ShapeStyle_RGBAColor_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ShapeEntity_ShapeStyle_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ShapeEntity_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_FrameEntity_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_MovieEntity_ImagesEntry_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_MovieEntity_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "svga.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
file_level_metadata[12].reflection = MovieEntity::MovieEntity_ImagesEntry::CreateReflection(file_level_metadata[12].descriptor, _MovieEntity_ImagesEntry_default_instance_.get_mutable());
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 14);
}

}  // namespace

void TableStruct::Shutdown() {
  _MovieParams_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _SpriteEntity_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _AudioEntity_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _Layout_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _Transform_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _ShapeEntity_ShapeArgs_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _ShapeEntity_RectArgs_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  _ShapeEntity_EllipseArgs_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
  _ShapeEntity_ShapeStyle_RGBAColor_default_instance_.Shutdown();
  delete file_level_metadata[8].reflection;
  _ShapeEntity_ShapeStyle_default_instance_.Shutdown();
  delete file_level_metadata[9].reflection;
  _ShapeEntity_default_instance_.Shutdown();
  delete file_level_metadata[10].reflection;
  _FrameEntity_default_instance_.Shutdown();
  delete file_level_metadata[11].reflection;
  _MovieEntity_default_instance_.Shutdown();
  delete file_level_metadata[13].reflection;
  delete file_level_metadata[12].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _MovieParams_default_instance_.DefaultConstruct();
  _SpriteEntity_default_instance_.DefaultConstruct();
  _AudioEntity_default_instance_.DefaultConstruct();
  _Layout_default_instance_.DefaultConstruct();
  _Transform_default_instance_.DefaultConstruct();
  _ShapeEntity_ShapeArgs_default_instance_.DefaultConstruct();
  _ShapeEntity_RectArgs_default_instance_.DefaultConstruct();
  _ShapeEntity_EllipseArgs_default_instance_.DefaultConstruct();
  _ShapeEntity_ShapeStyle_RGBAColor_default_instance_.DefaultConstruct();
  _ShapeEntity_ShapeStyle_default_instance_.DefaultConstruct();
  _ShapeEntity_default_instance_.DefaultConstruct();
  _FrameEntity_default_instance_.DefaultConstruct();
  _MovieEntity_ImagesEntry_default_instance_.DefaultConstruct();
  _MovieEntity_default_instance_.DefaultConstruct();
  _ShapeEntity_ShapeStyle_default_instance_.get_mutable()->fill_ = const_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor*>(
      ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor::internal_default_instance());
  _ShapeEntity_ShapeStyle_default_instance_.get_mutable()->stroke_ = const_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor*>(
      ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor::internal_default_instance());
  _ShapeEntity_default_instance_.shape_ = const_cast< ::com::opensource::svga::ShapeEntity_ShapeArgs*>(
      ::com::opensource::svga::ShapeEntity_ShapeArgs::internal_default_instance());
  _ShapeEntity_default_instance_.rect_ = const_cast< ::com::opensource::svga::ShapeEntity_RectArgs*>(
      ::com::opensource::svga::ShapeEntity_RectArgs::internal_default_instance());
  _ShapeEntity_default_instance_.ellipse_ = const_cast< ::com::opensource::svga::ShapeEntity_EllipseArgs*>(
      ::com::opensource::svga::ShapeEntity_EllipseArgs::internal_default_instance());
  _ShapeEntity_default_instance_.get_mutable()->styles_ = const_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle*>(
      ::com::opensource::svga::ShapeEntity_ShapeStyle::internal_default_instance());
  _ShapeEntity_default_instance_.get_mutable()->transform_ = const_cast< ::com::opensource::svga::Transform*>(
      ::com::opensource::svga::Transform::internal_default_instance());
  _FrameEntity_default_instance_.get_mutable()->layout_ = const_cast< ::com::opensource::svga::Layout*>(
      ::com::opensource::svga::Layout::internal_default_instance());
  _FrameEntity_default_instance_.get_mutable()->transform_ = const_cast< ::com::opensource::svga::Transform*>(
      ::com::opensource::svga::Transform::internal_default_instance());
  _MovieEntity_ImagesEntry_default_instance_.get_mutable()->set_default_instance(_MovieEntity_ImagesEntry_default_instance_.get_mutable());
  _MovieEntity_ImagesEntry_default_instance_.get_mutable()->InitAsDefaultInstance();
  _MovieEntity_default_instance_.get_mutable()->params_ = const_cast< ::com::opensource::svga::MovieParams*>(
      ::com::opensource::svga::MovieParams::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\nsvga.proto\022\023com.opensource.svga\"W\n\013Mov"
      "ieParams\022\024\n\014viewBoxWidth\030\001 \001(\002\022\025\n\rviewBo"
      "xHeight\030\002 \001(\002\022\013\n\003fps\030\003 \001(\005\022\016\n\006frames\030\004 \001"
      "(\005\"R\n\014SpriteEntity\022\020\n\010imageKey\030\001 \001(\t\0220\n\006"
      "frames\030\002 \003(\0132 .com.opensource.svga.Frame"
      "Entity\"k\n\013AudioEntity\022\020\n\010audioKey\030\001 \001(\t\022"
      "\022\n\nstartFrame\030\002 \001(\005\022\020\n\010endFrame\030\003 \001(\005\022\021\n"
      "\tstartTime\030\004 \001(\005\022\021\n\ttotalTime\030\005 \001(\005\"=\n\006L"
      "ayout\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\r\n\005width\030\003 \001"
      "(\002\022\016\n\006height\030\004 \001(\002\"O\n\tTransform\022\t\n\001a\030\001 \001"
      "(\002\022\t\n\001b\030\002 \001(\002\022\t\n\001c\030\003 \001(\002\022\t\n\001d\030\004 \001(\002\022\n\n\002t"
      "x\030\005 \001(\002\022\n\n\002ty\030\006 \001(\002\"\272\t\n\013ShapeEntity\0228\n\004t"
      "ype\030\001 \001(\0162*.com.opensource.svga.ShapeEnt"
      "ity.ShapeType\022;\n\005shape\030\002 \001(\0132*.com.opens"
      "ource.svga.ShapeEntity.ShapeArgsH\000\0229\n\004re"
      "ct\030\003 \001(\0132).com.opensource.svga.ShapeEnti"
      "ty.RectArgsH\000\022\?\n\007ellipse\030\004 \001(\0132,.com.ope"
      "nsource.svga.ShapeEntity.EllipseArgsH\000\022;"
      "\n\006styles\030\n \001(\0132+.com.opensource.svga.Sha"
      "peEntity.ShapeStyle\0221\n\ttransform\030\013 \001(\0132\036"
      ".com.opensource.svga.Transform\032\026\n\tShapeA"
      "rgs\022\t\n\001d\030\001 \001(\t\032U\n\010RectArgs\022\t\n\001x\030\001 \001(\002\022\t\n"
      "\001y\030\002 \001(\002\022\r\n\005width\030\003 \001(\002\022\016\n\006height\030\004 \001(\002\022"
      "\024\n\014cornerRadius\030\005 \001(\002\032E\n\013EllipseArgs\022\t\n\001"
      "x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\017\n\007radiusX\030\003 \001(\002\022\017\n\007r"
      "adiusY\030\004 \001(\002\032\320\004\n\nShapeStyle\022C\n\004fill\030\001 \001("
      "\01325.com.opensource.svga.ShapeEntity.Shap"
      "eStyle.RGBAColor\022E\n\006stroke\030\002 \001(\01325.com.o"
      "pensource.svga.ShapeEntity.ShapeStyle.RG"
      "BAColor\022\023\n\013strokeWidth\030\003 \001(\002\022D\n\007lineCap\030"
      "\004 \001(\01623.com.opensource.svga.ShapeEntity."
      "ShapeStyle.LineCap\022F\n\010lineJoin\030\005 \001(\01624.c"
      "om.opensource.svga.ShapeEntity.ShapeStyl"
      "e.LineJoin\022\022\n\nmiterLimit\030\006 \001(\002\022\021\n\tlineDa"
      "shI\030\007 \001(\002\022\022\n\nlineDashII\030\010 \001(\002\022\023\n\013lineDas"
      "hIII\030\t \001(\002\0327\n\tRGBAColor\022\t\n\001r\030\001 \001(\002\022\t\n\001g\030"
      "\002 \001(\002\022\t\n\001b\030\003 \001(\002\022\t\n\001a\030\004 \001(\002\"B\n\007LineCap\022\020"
      "\n\014LineCap_BUTT\020\000\022\021\n\rLineCap_ROUND\020\001\022\022\n\016L"
      "ineCap_SQUARE\020\002\"F\n\010LineJoin\022\022\n\016LineJoin_"
      "MITER\020\000\022\022\n\016LineJoin_ROUND\020\001\022\022\n\016LineJoin_"
      "BEVEL\020\002\"7\n\tShapeType\022\t\n\005SHAPE\020\000\022\010\n\004RECT\020"
      "\001\022\013\n\007ELLIPSE\020\002\022\010\n\004KEEP\020\003B\006\n\004args\"\300\001\n\013Fra"
      "meEntity\022\r\n\005alpha\030\001 \001(\002\022+\n\006layout\030\002 \001(\0132"
      "\033.com.opensource.svga.Layout\0221\n\ttransfor"
      "m\030\003 \001(\0132\036.com.opensource.svga.Transform\022"
      "\020\n\010clipPath\030\004 \001(\t\0220\n\006shapes\030\005 \003(\0132 .com."
      "opensource.svga.ShapeEntity\"\243\002\n\013MovieEnt"
      "ity\022\017\n\007version\030\001 \001(\t\0220\n\006params\030\002 \001(\0132 .c"
      "om.opensource.svga.MovieParams\022<\n\006images"
      "\030\003 \003(\0132,.com.opensource.svga.MovieEntity"
      ".ImagesEntry\0222\n\007sprites\030\004 \003(\0132!.com.open"
      "source.svga.SpriteEntity\0220\n\006audios\030\005 \003(\013"
      "2 .com.opensource.svga.AudioEntity\032-\n\013Im"
      "agesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\014:\0028"
      "\001B-\n\037com.opensource.svgaplayer.proto\242\002\tS"
      "VGAProtob\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 2216);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "svga.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_svga_2eproto

const ::google::protobuf::EnumDescriptor* ShapeEntity_ShapeStyle_LineCap_descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_enum_descriptors[0];
}
bool ShapeEntity_ShapeStyle_LineCap_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle::LineCap_BUTT;
const ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle::LineCap_ROUND;
const ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle::LineCap_SQUARE;
const ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle::LineCap_MIN;
const ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle::LineCap_MAX;
const int ShapeEntity_ShapeStyle::LineCap_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* ShapeEntity_ShapeStyle_LineJoin_descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_enum_descriptors[1];
}
bool ShapeEntity_ShapeStyle_LineJoin_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle::LineJoin_MITER;
const ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle::LineJoin_ROUND;
const ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle::LineJoin_BEVEL;
const ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle::LineJoin_MIN;
const ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle::LineJoin_MAX;
const int ShapeEntity_ShapeStyle::LineJoin_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* ShapeEntity_ShapeType_descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_enum_descriptors[2];
}
bool ShapeEntity_ShapeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ShapeEntity_ShapeType ShapeEntity::SHAPE;
const ShapeEntity_ShapeType ShapeEntity::RECT;
const ShapeEntity_ShapeType ShapeEntity::ELLIPSE;
const ShapeEntity_ShapeType ShapeEntity::KEEP;
const ShapeEntity_ShapeType ShapeEntity::ShapeType_MIN;
const ShapeEntity_ShapeType ShapeEntity::ShapeType_MAX;
const int ShapeEntity::ShapeType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MovieParams::kViewBoxWidthFieldNumber;
const int MovieParams::kViewBoxHeightFieldNumber;
const int MovieParams::kFpsFieldNumber;
const int MovieParams::kFramesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MovieParams::MovieParams()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.MovieParams)
}
MovieParams::MovieParams(const MovieParams& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&viewboxwidth_, &from.viewboxwidth_,
    reinterpret_cast<char*>(&frames_) -
    reinterpret_cast<char*>(&viewboxwidth_) + sizeof(frames_));
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.MovieParams)
}

void MovieParams::SharedCtor() {
  ::memset(&viewboxwidth_, 0, reinterpret_cast<char*>(&frames_) -
    reinterpret_cast<char*>(&viewboxwidth_) + sizeof(frames_));
  _cached_size_ = 0;
}

MovieParams::~MovieParams() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.MovieParams)
  SharedDtor();
}

void MovieParams::SharedDtor() {
}

void MovieParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MovieParams::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const MovieParams& MovieParams::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

MovieParams* MovieParams::New(::google::protobuf::Arena* arena) const {
  MovieParams* n = new MovieParams;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MovieParams::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.MovieParams)
  ::memset(&viewboxwidth_, 0, reinterpret_cast<char*>(&frames_) -
    reinterpret_cast<char*>(&viewboxwidth_) + sizeof(frames_));
}

bool MovieParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.MovieParams)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float viewBoxWidth = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &viewboxwidth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float viewBoxHeight = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &viewboxheight_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 fps = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fps_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 frames = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &frames_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.MovieParams)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.MovieParams)
  return false;
#undef DO_
}

void MovieParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.MovieParams)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float viewBoxWidth = 1;
  if (this->viewboxwidth() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->viewboxwidth(), output);
  }

  // float viewBoxHeight = 2;
  if (this->viewboxheight() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->viewboxheight(), output);
  }

  // int32 fps = 3;
  if (this->fps() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->fps(), output);
  }

  // int32 frames = 4;
  if (this->frames() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->frames(), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.MovieParams)
}

::google::protobuf::uint8* MovieParams::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.MovieParams)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float viewBoxWidth = 1;
  if (this->viewboxwidth() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->viewboxwidth(), target);
  }

  // float viewBoxHeight = 2;
  if (this->viewboxheight() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->viewboxheight(), target);
  }

  // int32 fps = 3;
  if (this->fps() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->fps(), target);
  }

  // int32 frames = 4;
  if (this->frames() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->frames(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.MovieParams)
  return target;
}

size_t MovieParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.MovieParams)
  size_t total_size = 0;

  // float viewBoxWidth = 1;
  if (this->viewboxwidth() != 0) {
    total_size += 1 + 4;
  }

  // float viewBoxHeight = 2;
  if (this->viewboxheight() != 0) {
    total_size += 1 + 4;
  }

  // int32 fps = 3;
  if (this->fps() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->fps());
  }

  // int32 frames = 4;
  if (this->frames() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->frames());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MovieParams::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.MovieParams)
  GOOGLE_DCHECK_NE(&from, this);
  const MovieParams* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const MovieParams>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.MovieParams)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.MovieParams)
    MergeFrom(*source);
  }
}

void MovieParams::MergeFrom(const MovieParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.MovieParams)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.viewboxwidth() != 0) {
    set_viewboxwidth(from.viewboxwidth());
  }
  if (from.viewboxheight() != 0) {
    set_viewboxheight(from.viewboxheight());
  }
  if (from.fps() != 0) {
    set_fps(from.fps());
  }
  if (from.frames() != 0) {
    set_frames(from.frames());
  }
}

void MovieParams::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.MovieParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MovieParams::CopyFrom(const MovieParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.MovieParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovieParams::IsInitialized() const {
  return true;
}

void MovieParams::Swap(MovieParams* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MovieParams::InternalSwap(MovieParams* other) {
  std::swap(viewboxwidth_, other->viewboxwidth_);
  std::swap(viewboxheight_, other->viewboxheight_);
  std::swap(fps_, other->fps_);
  std::swap(frames_, other->frames_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MovieParams::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MovieParams

// float viewBoxWidth = 1;
void MovieParams::clear_viewboxwidth() {
  viewboxwidth_ = 0;
}
float MovieParams::viewboxwidth() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.viewBoxWidth)
  return viewboxwidth_;
}
void MovieParams::set_viewboxwidth(float value) {
  
  viewboxwidth_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.viewBoxWidth)
}

// float viewBoxHeight = 2;
void MovieParams::clear_viewboxheight() {
  viewboxheight_ = 0;
}
float MovieParams::viewboxheight() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.viewBoxHeight)
  return viewboxheight_;
}
void MovieParams::set_viewboxheight(float value) {
  
  viewboxheight_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.viewBoxHeight)
}

// int32 fps = 3;
void MovieParams::clear_fps() {
  fps_ = 0;
}
::google::protobuf::int32 MovieParams::fps() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.fps)
  return fps_;
}
void MovieParams::set_fps(::google::protobuf::int32 value) {
  
  fps_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.fps)
}

// int32 frames = 4;
void MovieParams::clear_frames() {
  frames_ = 0;
}
::google::protobuf::int32 MovieParams::frames() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.frames)
  return frames_;
}
void MovieParams::set_frames(::google::protobuf::int32 value) {
  
  frames_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.frames)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SpriteEntity::kImageKeyFieldNumber;
const int SpriteEntity::kFramesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SpriteEntity::SpriteEntity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.SpriteEntity)
}
SpriteEntity::SpriteEntity(const SpriteEntity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      frames_(from.frames_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  imagekey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.imagekey().size() > 0) {
    imagekey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.imagekey_);
  }
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.SpriteEntity)
}

void SpriteEntity::SharedCtor() {
  imagekey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

SpriteEntity::~SpriteEntity() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.SpriteEntity)
  SharedDtor();
}

void SpriteEntity::SharedDtor() {
  imagekey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void SpriteEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SpriteEntity::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SpriteEntity& SpriteEntity::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

SpriteEntity* SpriteEntity::New(::google::protobuf::Arena* arena) const {
  SpriteEntity* n = new SpriteEntity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SpriteEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.SpriteEntity)
  frames_.Clear();
  imagekey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SpriteEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.SpriteEntity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string imageKey = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_imagekey()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->imagekey().data(), this->imagekey().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "com.opensource.svga.SpriteEntity.imageKey"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .com.opensource.svga.FrameEntity frames = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frames()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.SpriteEntity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.SpriteEntity)
  return false;
#undef DO_
}

void SpriteEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.SpriteEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string imageKey = 1;
  if (this->imagekey().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->imagekey().data(), this->imagekey().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.SpriteEntity.imageKey");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->imagekey(), output);
  }

  // repeated .com.opensource.svga.FrameEntity frames = 2;
  for (unsigned int i = 0, n = this->frames_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->frames(i), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.SpriteEntity)
}

::google::protobuf::uint8* SpriteEntity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.SpriteEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string imageKey = 1;
  if (this->imagekey().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->imagekey().data(), this->imagekey().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.SpriteEntity.imageKey");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->imagekey(), target);
  }

  // repeated .com.opensource.svga.FrameEntity frames = 2;
  for (unsigned int i = 0, n = this->frames_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->frames(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.SpriteEntity)
  return target;
}

size_t SpriteEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.SpriteEntity)
  size_t total_size = 0;

  // repeated .com.opensource.svga.FrameEntity frames = 2;
  {
    unsigned int count = this->frames_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->frames(i));
    }
  }

  // string imageKey = 1;
  if (this->imagekey().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->imagekey());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SpriteEntity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.SpriteEntity)
  GOOGLE_DCHECK_NE(&from, this);
  const SpriteEntity* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SpriteEntity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.SpriteEntity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.SpriteEntity)
    MergeFrom(*source);
  }
}

void SpriteEntity::MergeFrom(const SpriteEntity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.SpriteEntity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  frames_.MergeFrom(from.frames_);
  if (from.imagekey().size() > 0) {

    imagekey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.imagekey_);
  }
}

void SpriteEntity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.SpriteEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpriteEntity::CopyFrom(const SpriteEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.SpriteEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpriteEntity::IsInitialized() const {
  return true;
}

void SpriteEntity::Swap(SpriteEntity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SpriteEntity::InternalSwap(SpriteEntity* other) {
  frames_.InternalSwap(&other->frames_);
  imagekey_.Swap(&other->imagekey_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SpriteEntity::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SpriteEntity

// string imageKey = 1;
void SpriteEntity::clear_imagekey() {
  imagekey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& SpriteEntity::imagekey() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.SpriteEntity.imageKey)
  return imagekey_.GetNoArena();
}
void SpriteEntity::set_imagekey(const ::std::string& value) {
  
  imagekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.SpriteEntity.imageKey)
}
#if LANG_CXX11
void SpriteEntity::set_imagekey(::std::string&& value) {
  
  imagekey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.SpriteEntity.imageKey)
}
#endif
void SpriteEntity::set_imagekey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  imagekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.SpriteEntity.imageKey)
}
void SpriteEntity::set_imagekey(const char* value, size_t size) {
  
  imagekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.SpriteEntity.imageKey)
}
::std::string* SpriteEntity::mutable_imagekey() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.SpriteEntity.imageKey)
  return imagekey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SpriteEntity::release_imagekey() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.SpriteEntity.imageKey)
  
  return imagekey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpriteEntity::set_allocated_imagekey(::std::string* imagekey) {
  if (imagekey != NULL) {
    
  } else {
    
  }
  imagekey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imagekey);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.SpriteEntity.imageKey)
}

// repeated .com.opensource.svga.FrameEntity frames = 2;
int SpriteEntity::frames_size() const {
  return frames_.size();
}
void SpriteEntity::clear_frames() {
  frames_.Clear();
}
const ::com::opensource::svga::FrameEntity& SpriteEntity::frames(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.SpriteEntity.frames)
  return frames_.Get(index);
}
::com::opensource::svga::FrameEntity* SpriteEntity::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.SpriteEntity.frames)
  return frames_.Mutable(index);
}
::com::opensource::svga::FrameEntity* SpriteEntity::add_frames() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.SpriteEntity.frames)
  return frames_.Add();
}
::google::protobuf::RepeatedPtrField< ::com::opensource::svga::FrameEntity >*
SpriteEntity::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.SpriteEntity.frames)
  return &frames_;
}
const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::FrameEntity >&
SpriteEntity::frames() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.SpriteEntity.frames)
  return frames_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AudioEntity::kAudioKeyFieldNumber;
const int AudioEntity::kStartFrameFieldNumber;
const int AudioEntity::kEndFrameFieldNumber;
const int AudioEntity::kStartTimeFieldNumber;
const int AudioEntity::kTotalTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AudioEntity::AudioEntity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.AudioEntity)
}
AudioEntity::AudioEntity(const AudioEntity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  audiokey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.audiokey().size() > 0) {
    audiokey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.audiokey_);
  }
  ::memcpy(&startframe_, &from.startframe_,
    reinterpret_cast<char*>(&totaltime_) -
    reinterpret_cast<char*>(&startframe_) + sizeof(totaltime_));
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.AudioEntity)
}

void AudioEntity::SharedCtor() {
  audiokey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&startframe_, 0, reinterpret_cast<char*>(&totaltime_) -
    reinterpret_cast<char*>(&startframe_) + sizeof(totaltime_));
  _cached_size_ = 0;
}

AudioEntity::~AudioEntity() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.AudioEntity)
  SharedDtor();
}

void AudioEntity::SharedDtor() {
  audiokey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void AudioEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioEntity::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const AudioEntity& AudioEntity::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

AudioEntity* AudioEntity::New(::google::protobuf::Arena* arena) const {
  AudioEntity* n = new AudioEntity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AudioEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.AudioEntity)
  audiokey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&startframe_, 0, reinterpret_cast<char*>(&totaltime_) -
    reinterpret_cast<char*>(&startframe_) + sizeof(totaltime_));
}

bool AudioEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.AudioEntity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string audioKey = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_audiokey()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->audiokey().data(), this->audiokey().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "com.opensource.svga.AudioEntity.audioKey"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 startFrame = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &startframe_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 endFrame = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &endframe_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 startTime = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &starttime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 totalTime = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &totaltime_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.AudioEntity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.AudioEntity)
  return false;
#undef DO_
}

void AudioEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.AudioEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string audioKey = 1;
  if (this->audiokey().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->audiokey().data(), this->audiokey().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.AudioEntity.audioKey");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->audiokey(), output);
  }

  // int32 startFrame = 2;
  if (this->startframe() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->startframe(), output);
  }

  // int32 endFrame = 3;
  if (this->endframe() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->endframe(), output);
  }

  // int32 startTime = 4;
  if (this->starttime() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->starttime(), output);
  }

  // int32 totalTime = 5;
  if (this->totaltime() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->totaltime(), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.AudioEntity)
}

::google::protobuf::uint8* AudioEntity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.AudioEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string audioKey = 1;
  if (this->audiokey().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->audiokey().data(), this->audiokey().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.AudioEntity.audioKey");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->audiokey(), target);
  }

  // int32 startFrame = 2;
  if (this->startframe() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->startframe(), target);
  }

  // int32 endFrame = 3;
  if (this->endframe() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->endframe(), target);
  }

  // int32 startTime = 4;
  if (this->starttime() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->starttime(), target);
  }

  // int32 totalTime = 5;
  if (this->totaltime() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->totaltime(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.AudioEntity)
  return target;
}

size_t AudioEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.AudioEntity)
  size_t total_size = 0;

  // string audioKey = 1;
  if (this->audiokey().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->audiokey());
  }

  // int32 startFrame = 2;
  if (this->startframe() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->startframe());
  }

  // int32 endFrame = 3;
  if (this->endframe() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->endframe());
  }

  // int32 startTime = 4;
  if (this->starttime() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->starttime());
  }

  // int32 totalTime = 5;
  if (this->totaltime() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->totaltime());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioEntity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.AudioEntity)
  GOOGLE_DCHECK_NE(&from, this);
  const AudioEntity* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const AudioEntity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.AudioEntity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.AudioEntity)
    MergeFrom(*source);
  }
}

void AudioEntity::MergeFrom(const AudioEntity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.AudioEntity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.audiokey().size() > 0) {

    audiokey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.audiokey_);
  }
  if (from.startframe() != 0) {
    set_startframe(from.startframe());
  }
  if (from.endframe() != 0) {
    set_endframe(from.endframe());
  }
  if (from.starttime() != 0) {
    set_starttime(from.starttime());
  }
  if (from.totaltime() != 0) {
    set_totaltime(from.totaltime());
  }
}

void AudioEntity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.AudioEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioEntity::CopyFrom(const AudioEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.AudioEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioEntity::IsInitialized() const {
  return true;
}

void AudioEntity::Swap(AudioEntity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AudioEntity::InternalSwap(AudioEntity* other) {
  audiokey_.Swap(&other->audiokey_);
  std::swap(startframe_, other->startframe_);
  std::swap(endframe_, other->endframe_);
  std::swap(starttime_, other->starttime_);
  std::swap(totaltime_, other->totaltime_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AudioEntity::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AudioEntity

// string audioKey = 1;
void AudioEntity::clear_audiokey() {
  audiokey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& AudioEntity::audiokey() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.audioKey)
  return audiokey_.GetNoArena();
}
void AudioEntity::set_audiokey(const ::std::string& value) {
  
  audiokey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.audioKey)
}
#if LANG_CXX11
void AudioEntity::set_audiokey(::std::string&& value) {
  
  audiokey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.AudioEntity.audioKey)
}
#endif
void AudioEntity::set_audiokey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  audiokey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.AudioEntity.audioKey)
}
void AudioEntity::set_audiokey(const char* value, size_t size) {
  
  audiokey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.AudioEntity.audioKey)
}
::std::string* AudioEntity::mutable_audiokey() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.AudioEntity.audioKey)
  return audiokey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* AudioEntity::release_audiokey() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.AudioEntity.audioKey)
  
  return audiokey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AudioEntity::set_allocated_audiokey(::std::string* audiokey) {
  if (audiokey != NULL) {
    
  } else {
    
  }
  audiokey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), audiokey);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.AudioEntity.audioKey)
}

// int32 startFrame = 2;
void AudioEntity::clear_startframe() {
  startframe_ = 0;
}
::google::protobuf::int32 AudioEntity::startframe() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.startFrame)
  return startframe_;
}
void AudioEntity::set_startframe(::google::protobuf::int32 value) {
  
  startframe_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.startFrame)
}

// int32 endFrame = 3;
void AudioEntity::clear_endframe() {
  endframe_ = 0;
}
::google::protobuf::int32 AudioEntity::endframe() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.endFrame)
  return endframe_;
}
void AudioEntity::set_endframe(::google::protobuf::int32 value) {
  
  endframe_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.endFrame)
}

// int32 startTime = 4;
void AudioEntity::clear_starttime() {
  starttime_ = 0;
}
::google::protobuf::int32 AudioEntity::starttime() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.startTime)
  return starttime_;
}
void AudioEntity::set_starttime(::google::protobuf::int32 value) {
  
  starttime_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.startTime)
}

// int32 totalTime = 5;
void AudioEntity::clear_totaltime() {
  totaltime_ = 0;
}
::google::protobuf::int32 AudioEntity::totaltime() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.totalTime)
  return totaltime_;
}
void AudioEntity::set_totaltime(::google::protobuf::int32 value) {
  
  totaltime_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.totalTime)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Layout::kXFieldNumber;
const int Layout::kYFieldNumber;
const int Layout::kWidthFieldNumber;
const int Layout::kHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Layout::Layout()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.Layout)
}
Layout::Layout(const Layout& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&x_) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.Layout)
}

void Layout::SharedCtor() {
  ::memset(&x_, 0, reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&x_) + sizeof(height_));
  _cached_size_ = 0;
}

Layout::~Layout() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.Layout)
  SharedDtor();
}

void Layout::SharedDtor() {
}

void Layout::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Layout::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Layout& Layout::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

Layout* Layout::New(::google::protobuf::Arena* arena) const {
  Layout* n = new Layout;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Layout::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.Layout)
  ::memset(&x_, 0, reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&x_) + sizeof(height_));
}

bool Layout::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.Layout)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float width = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float height = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.Layout)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.Layout)
  return false;
#undef DO_
}

void Layout::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.Layout)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // float y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // float width = 3;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->width(), output);
  }

  // float height = 4;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->height(), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.Layout)
}

::google::protobuf::uint8* Layout::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.Layout)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // float y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // float width = 3;
  if (this->width() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->width(), target);
  }

  // float height = 4;
  if (this->height() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->height(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.Layout)
  return target;
}

size_t Layout::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.Layout)
  size_t total_size = 0;

  // float x = 1;
  if (this->x() != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (this->y() != 0) {
    total_size += 1 + 4;
  }

  // float width = 3;
  if (this->width() != 0) {
    total_size += 1 + 4;
  }

  // float height = 4;
  if (this->height() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Layout::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.Layout)
  GOOGLE_DCHECK_NE(&from, this);
  const Layout* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Layout>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.Layout)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.Layout)
    MergeFrom(*source);
  }
}

void Layout::MergeFrom(const Layout& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.Layout)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
}

void Layout::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.Layout)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Layout::CopyFrom(const Layout& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.Layout)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Layout::IsInitialized() const {
  return true;
}

void Layout::Swap(Layout* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Layout::InternalSwap(Layout* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Layout::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Layout

// float x = 1;
void Layout::clear_x() {
  x_ = 0;
}
float Layout::x() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.x)
  return x_;
}
void Layout::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.x)
}

// float y = 2;
void Layout::clear_y() {
  y_ = 0;
}
float Layout::y() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.y)
  return y_;
}
void Layout::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.y)
}

// float width = 3;
void Layout::clear_width() {
  width_ = 0;
}
float Layout::width() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.width)
  return width_;
}
void Layout::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.width)
}

// float height = 4;
void Layout::clear_height() {
  height_ = 0;
}
float Layout::height() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.height)
  return height_;
}
void Layout::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.height)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Transform::kAFieldNumber;
const int Transform::kBFieldNumber;
const int Transform::kCFieldNumber;
const int Transform::kDFieldNumber;
const int Transform::kTxFieldNumber;
const int Transform::kTyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Transform::Transform()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.Transform)
}
Transform::Transform(const Transform& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&a_, &from.a_,
    reinterpret_cast<char*>(&ty_) -
    reinterpret_cast<char*>(&a_) + sizeof(ty_));
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.Transform)
}

void Transform::SharedCtor() {
  ::memset(&a_, 0, reinterpret_cast<char*>(&ty_) -
    reinterpret_cast<char*>(&a_) + sizeof(ty_));
  _cached_size_ = 0;
}

Transform::~Transform() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.Transform)
  SharedDtor();
}

void Transform::SharedDtor() {
}

void Transform::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Transform::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Transform& Transform::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

Transform* Transform::New(::google::protobuf::Arena* arena) const {
  Transform* n = new Transform;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Transform::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.Transform)
  ::memset(&a_, 0, reinterpret_cast<char*>(&ty_) -
    reinterpret_cast<char*>(&a_) + sizeof(ty_));
}

bool Transform::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.Transform)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float a = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &a_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float b = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &b_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float c = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &c_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float d = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &d_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float tx = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(45u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &tx_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float ty = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ty_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.Transform)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.Transform)
  return false;
#undef DO_
}

void Transform::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.Transform)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float a = 1;
  if (this->a() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->a(), output);
  }

  // float b = 2;
  if (this->b() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->b(), output);
  }

  // float c = 3;
  if (this->c() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->c(), output);
  }

  // float d = 4;
  if (this->d() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->d(), output);
  }

  // float tx = 5;
  if (this->tx() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->tx(), output);
  }

  // float ty = 6;
  if (this->ty() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->ty(), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.Transform)
}

::google::protobuf::uint8* Transform::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.Transform)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float a = 1;
  if (this->a() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->a(), target);
  }

  // float b = 2;
  if (this->b() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->b(), target);
  }

  // float c = 3;
  if (this->c() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->c(), target);
  }

  // float d = 4;
  if (this->d() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->d(), target);
  }

  // float tx = 5;
  if (this->tx() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->tx(), target);
  }

  // float ty = 6;
  if (this->ty() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->ty(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.Transform)
  return target;
}

size_t Transform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.Transform)
  size_t total_size = 0;

  // float a = 1;
  if (this->a() != 0) {
    total_size += 1 + 4;
  }

  // float b = 2;
  if (this->b() != 0) {
    total_size += 1 + 4;
  }

  // float c = 3;
  if (this->c() != 0) {
    total_size += 1 + 4;
  }

  // float d = 4;
  if (this->d() != 0) {
    total_size += 1 + 4;
  }

  // float tx = 5;
  if (this->tx() != 0) {
    total_size += 1 + 4;
  }

  // float ty = 6;
  if (this->ty() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Transform::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.Transform)
  GOOGLE_DCHECK_NE(&from, this);
  const Transform* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Transform>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.Transform)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.Transform)
    MergeFrom(*source);
  }
}

void Transform::MergeFrom(const Transform& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.Transform)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.a() != 0) {
    set_a(from.a());
  }
  if (from.b() != 0) {
    set_b(from.b());
  }
  if (from.c() != 0) {
    set_c(from.c());
  }
  if (from.d() != 0) {
    set_d(from.d());
  }
  if (from.tx() != 0) {
    set_tx(from.tx());
  }
  if (from.ty() != 0) {
    set_ty(from.ty());
  }
}

void Transform::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.Transform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Transform::CopyFrom(const Transform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.Transform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transform::IsInitialized() const {
  return true;
}

void Transform::Swap(Transform* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Transform::InternalSwap(Transform* other) {
  std::swap(a_, other->a_);
  std::swap(b_, other->b_);
  std::swap(c_, other->c_);
  std::swap(d_, other->d_);
  std::swap(tx_, other->tx_);
  std::swap(ty_, other->ty_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Transform::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Transform

// float a = 1;
void Transform::clear_a() {
  a_ = 0;
}
float Transform::a() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.a)
  return a_;
}
void Transform::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.a)
}

// float b = 2;
void Transform::clear_b() {
  b_ = 0;
}
float Transform::b() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.b)
  return b_;
}
void Transform::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.b)
}

// float c = 3;
void Transform::clear_c() {
  c_ = 0;
}
float Transform::c() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.c)
  return c_;
}
void Transform::set_c(float value) {
  
  c_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.c)
}

// float d = 4;
void Transform::clear_d() {
  d_ = 0;
}
float Transform::d() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.d)
  return d_;
}
void Transform::set_d(float value) {
  
  d_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.d)
}

// float tx = 5;
void Transform::clear_tx() {
  tx_ = 0;
}
float Transform::tx() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.tx)
  return tx_;
}
void Transform::set_tx(float value) {
  
  tx_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.tx)
}

// float ty = 6;
void Transform::clear_ty() {
  ty_ = 0;
}
float Transform::ty() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.ty)
  return ty_;
}
void Transform::set_ty(float value) {
  
  ty_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.ty)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShapeEntity_ShapeArgs::kDFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ShapeEntity_ShapeArgs::ShapeEntity_ShapeArgs()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.ShapeEntity.ShapeArgs)
}
ShapeEntity_ShapeArgs::ShapeEntity_ShapeArgs(const ShapeEntity_ShapeArgs& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  d_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.d().size() > 0) {
    d_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.d_);
  }
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.ShapeEntity.ShapeArgs)
}

void ShapeEntity_ShapeArgs::SharedCtor() {
  d_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

ShapeEntity_ShapeArgs::~ShapeEntity_ShapeArgs() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.ShapeEntity.ShapeArgs)
  SharedDtor();
}

void ShapeEntity_ShapeArgs::SharedDtor() {
  d_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ShapeEntity_ShapeArgs::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShapeEntity_ShapeArgs::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ShapeEntity_ShapeArgs& ShapeEntity_ShapeArgs::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

ShapeEntity_ShapeArgs* ShapeEntity_ShapeArgs::New(::google::protobuf::Arena* arena) const {
  ShapeEntity_ShapeArgs* n = new ShapeEntity_ShapeArgs;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ShapeEntity_ShapeArgs::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.ShapeEntity.ShapeArgs)
  d_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ShapeEntity_ShapeArgs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.ShapeEntity.ShapeArgs)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string d = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_d()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->d().data(), this->d().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "com.opensource.svga.ShapeEntity.ShapeArgs.d"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.ShapeEntity.ShapeArgs)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.ShapeEntity.ShapeArgs)
  return false;
#undef DO_
}

void ShapeEntity_ShapeArgs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.ShapeEntity.ShapeArgs)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string d = 1;
  if (this->d().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->d().data(), this->d().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.ShapeEntity.ShapeArgs.d");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->d(), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.ShapeEntity.ShapeArgs)
}

::google::protobuf::uint8* ShapeEntity_ShapeArgs::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.ShapeEntity.ShapeArgs)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string d = 1;
  if (this->d().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->d().data(), this->d().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.ShapeEntity.ShapeArgs.d");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->d(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.ShapeEntity.ShapeArgs)
  return target;
}

size_t ShapeEntity_ShapeArgs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.ShapeEntity.ShapeArgs)
  size_t total_size = 0;

  // string d = 1;
  if (this->d().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->d());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShapeEntity_ShapeArgs::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.ShapeEntity.ShapeArgs)
  GOOGLE_DCHECK_NE(&from, this);
  const ShapeEntity_ShapeArgs* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ShapeEntity_ShapeArgs>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.ShapeEntity.ShapeArgs)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.ShapeEntity.ShapeArgs)
    MergeFrom(*source);
  }
}

void ShapeEntity_ShapeArgs::MergeFrom(const ShapeEntity_ShapeArgs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.ShapeEntity.ShapeArgs)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.d().size() > 0) {

    d_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.d_);
  }
}

void ShapeEntity_ShapeArgs::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.ShapeEntity.ShapeArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShapeEntity_ShapeArgs::CopyFrom(const ShapeEntity_ShapeArgs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.ShapeEntity.ShapeArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeEntity_ShapeArgs::IsInitialized() const {
  return true;
}

void ShapeEntity_ShapeArgs::Swap(ShapeEntity_ShapeArgs* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ShapeEntity_ShapeArgs::InternalSwap(ShapeEntity_ShapeArgs* other) {
  d_.Swap(&other->d_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ShapeEntity_ShapeArgs::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShapeEntity_ShapeArgs

// string d = 1;
void ShapeEntity_ShapeArgs::clear_d() {
  d_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& ShapeEntity_ShapeArgs::d() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeArgs.d)
  return d_.GetNoArena();
}
void ShapeEntity_ShapeArgs::set_d(const ::std::string& value) {
  
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
#if LANG_CXX11
void ShapeEntity_ShapeArgs::set_d(::std::string&& value) {
  
  d_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
#endif
void ShapeEntity_ShapeArgs::set_d(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
void ShapeEntity_ShapeArgs::set_d(const char* value, size_t size) {
  
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
::std::string* ShapeEntity_ShapeArgs::mutable_d() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ShapeArgs.d)
  return d_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ShapeEntity_ShapeArgs::release_d() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ShapeArgs.d)
  
  return d_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ShapeEntity_ShapeArgs::set_allocated_d(::std::string* d) {
  if (d != NULL) {
    
  } else {
    
  }
  d_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), d);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShapeEntity_RectArgs::kXFieldNumber;
const int ShapeEntity_RectArgs::kYFieldNumber;
const int ShapeEntity_RectArgs::kWidthFieldNumber;
const int ShapeEntity_RectArgs::kHeightFieldNumber;
const int ShapeEntity_RectArgs::kCornerRadiusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ShapeEntity_RectArgs::ShapeEntity_RectArgs()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.ShapeEntity.RectArgs)
}
ShapeEntity_RectArgs::ShapeEntity_RectArgs(const ShapeEntity_RectArgs& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    reinterpret_cast<char*>(&cornerradius_) -
    reinterpret_cast<char*>(&x_) + sizeof(cornerradius_));
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.ShapeEntity.RectArgs)
}

void ShapeEntity_RectArgs::SharedCtor() {
  ::memset(&x_, 0, reinterpret_cast<char*>(&cornerradius_) -
    reinterpret_cast<char*>(&x_) + sizeof(cornerradius_));
  _cached_size_ = 0;
}

ShapeEntity_RectArgs::~ShapeEntity_RectArgs() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.ShapeEntity.RectArgs)
  SharedDtor();
}

void ShapeEntity_RectArgs::SharedDtor() {
}

void ShapeEntity_RectArgs::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShapeEntity_RectArgs::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ShapeEntity_RectArgs& ShapeEntity_RectArgs::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

ShapeEntity_RectArgs* ShapeEntity_RectArgs::New(::google::protobuf::Arena* arena) const {
  ShapeEntity_RectArgs* n = new ShapeEntity_RectArgs;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ShapeEntity_RectArgs::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.ShapeEntity.RectArgs)
  ::memset(&x_, 0, reinterpret_cast<char*>(&cornerradius_) -
    reinterpret_cast<char*>(&x_) + sizeof(cornerradius_));
}

bool ShapeEntity_RectArgs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.ShapeEntity.RectArgs)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float width = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float height = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float cornerRadius = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(45u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cornerradius_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.ShapeEntity.RectArgs)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.ShapeEntity.RectArgs)
  return false;
#undef DO_
}

void ShapeEntity_RectArgs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.ShapeEntity.RectArgs)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // float y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // float width = 3;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->width(), output);
  }

  // float height = 4;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->height(), output);
  }

  // float cornerRadius = 5;
  if (this->cornerradius() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->cornerradius(), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.ShapeEntity.RectArgs)
}

::google::protobuf::uint8* ShapeEntity_RectArgs::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.ShapeEntity.RectArgs)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // float y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // float width = 3;
  if (this->width() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->width(), target);
  }

  // float height = 4;
  if (this->height() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->height(), target);
  }

  // float cornerRadius = 5;
  if (this->cornerradius() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->cornerradius(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.ShapeEntity.RectArgs)
  return target;
}

size_t ShapeEntity_RectArgs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.ShapeEntity.RectArgs)
  size_t total_size = 0;

  // float x = 1;
  if (this->x() != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (this->y() != 0) {
    total_size += 1 + 4;
  }

  // float width = 3;
  if (this->width() != 0) {
    total_size += 1 + 4;
  }

  // float height = 4;
  if (this->height() != 0) {
    total_size += 1 + 4;
  }

  // float cornerRadius = 5;
  if (this->cornerradius() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShapeEntity_RectArgs::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.ShapeEntity.RectArgs)
  GOOGLE_DCHECK_NE(&from, this);
  const ShapeEntity_RectArgs* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ShapeEntity_RectArgs>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.ShapeEntity.RectArgs)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.ShapeEntity.RectArgs)
    MergeFrom(*source);
  }
}

void ShapeEntity_RectArgs::MergeFrom(const ShapeEntity_RectArgs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.ShapeEntity.RectArgs)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
  if (from.cornerradius() != 0) {
    set_cornerradius(from.cornerradius());
  }
}

void ShapeEntity_RectArgs::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.ShapeEntity.RectArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShapeEntity_RectArgs::CopyFrom(const ShapeEntity_RectArgs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.ShapeEntity.RectArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeEntity_RectArgs::IsInitialized() const {
  return true;
}

void ShapeEntity_RectArgs::Swap(ShapeEntity_RectArgs* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ShapeEntity_RectArgs::InternalSwap(ShapeEntity_RectArgs* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(cornerradius_, other->cornerradius_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ShapeEntity_RectArgs::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShapeEntity_RectArgs

// float x = 1;
void ShapeEntity_RectArgs::clear_x() {
  x_ = 0;
}
float ShapeEntity_RectArgs::x() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.x)
  return x_;
}
void ShapeEntity_RectArgs::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.x)
}

// float y = 2;
void ShapeEntity_RectArgs::clear_y() {
  y_ = 0;
}
float ShapeEntity_RectArgs::y() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.y)
  return y_;
}
void ShapeEntity_RectArgs::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.y)
}

// float width = 3;
void ShapeEntity_RectArgs::clear_width() {
  width_ = 0;
}
float ShapeEntity_RectArgs::width() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.width)
  return width_;
}
void ShapeEntity_RectArgs::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.width)
}

// float height = 4;
void ShapeEntity_RectArgs::clear_height() {
  height_ = 0;
}
float ShapeEntity_RectArgs::height() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.height)
  return height_;
}
void ShapeEntity_RectArgs::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.height)
}

// float cornerRadius = 5;
void ShapeEntity_RectArgs::clear_cornerradius() {
  cornerradius_ = 0;
}
float ShapeEntity_RectArgs::cornerradius() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.cornerRadius)
  return cornerradius_;
}
void ShapeEntity_RectArgs::set_cornerradius(float value) {
  
  cornerradius_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.cornerRadius)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShapeEntity_EllipseArgs::kXFieldNumber;
const int ShapeEntity_EllipseArgs::kYFieldNumber;
const int ShapeEntity_EllipseArgs::kRadiusXFieldNumber;
const int ShapeEntity_EllipseArgs::kRadiusYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ShapeEntity_EllipseArgs::ShapeEntity_EllipseArgs()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.ShapeEntity.EllipseArgs)
}
ShapeEntity_EllipseArgs::ShapeEntity_EllipseArgs(const ShapeEntity_EllipseArgs& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    reinterpret_cast<char*>(&radiusy_) -
    reinterpret_cast<char*>(&x_) + sizeof(radiusy_));
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.ShapeEntity.EllipseArgs)
}

void ShapeEntity_EllipseArgs::SharedCtor() {
  ::memset(&x_, 0, reinterpret_cast<char*>(&radiusy_) -
    reinterpret_cast<char*>(&x_) + sizeof(radiusy_));
  _cached_size_ = 0;
}

ShapeEntity_EllipseArgs::~ShapeEntity_EllipseArgs() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.ShapeEntity.EllipseArgs)
  SharedDtor();
}

void ShapeEntity_EllipseArgs::SharedDtor() {
}

void ShapeEntity_EllipseArgs::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShapeEntity_EllipseArgs::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ShapeEntity_EllipseArgs& ShapeEntity_EllipseArgs::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

ShapeEntity_EllipseArgs* ShapeEntity_EllipseArgs::New(::google::protobuf::Arena* arena) const {
  ShapeEntity_EllipseArgs* n = new ShapeEntity_EllipseArgs;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ShapeEntity_EllipseArgs::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.ShapeEntity.EllipseArgs)
  ::memset(&x_, 0, reinterpret_cast<char*>(&radiusy_) -
    reinterpret_cast<char*>(&x_) + sizeof(radiusy_));
}

bool ShapeEntity_EllipseArgs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.ShapeEntity.EllipseArgs)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float radiusX = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radiusx_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float radiusY = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radiusy_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.ShapeEntity.EllipseArgs)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.ShapeEntity.EllipseArgs)
  return false;
#undef DO_
}

void ShapeEntity_EllipseArgs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.ShapeEntity.EllipseArgs)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // float y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // float radiusX = 3;
  if (this->radiusx() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->radiusx(), output);
  }

  // float radiusY = 4;
  if (this->radiusy() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->radiusy(), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.ShapeEntity.EllipseArgs)
}

::google::protobuf::uint8* ShapeEntity_EllipseArgs::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.ShapeEntity.EllipseArgs)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // float y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // float radiusX = 3;
  if (this->radiusx() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->radiusx(), target);
  }

  // float radiusY = 4;
  if (this->radiusy() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->radiusy(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.ShapeEntity.EllipseArgs)
  return target;
}

size_t ShapeEntity_EllipseArgs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.ShapeEntity.EllipseArgs)
  size_t total_size = 0;

  // float x = 1;
  if (this->x() != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (this->y() != 0) {
    total_size += 1 + 4;
  }

  // float radiusX = 3;
  if (this->radiusx() != 0) {
    total_size += 1 + 4;
  }

  // float radiusY = 4;
  if (this->radiusy() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShapeEntity_EllipseArgs::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.ShapeEntity.EllipseArgs)
  GOOGLE_DCHECK_NE(&from, this);
  const ShapeEntity_EllipseArgs* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ShapeEntity_EllipseArgs>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.ShapeEntity.EllipseArgs)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.ShapeEntity.EllipseArgs)
    MergeFrom(*source);
  }
}

void ShapeEntity_EllipseArgs::MergeFrom(const ShapeEntity_EllipseArgs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.ShapeEntity.EllipseArgs)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.radiusx() != 0) {
    set_radiusx(from.radiusx());
  }
  if (from.radiusy() != 0) {
    set_radiusy(from.radiusy());
  }
}

void ShapeEntity_EllipseArgs::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.ShapeEntity.EllipseArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShapeEntity_EllipseArgs::CopyFrom(const ShapeEntity_EllipseArgs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.ShapeEntity.EllipseArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeEntity_EllipseArgs::IsInitialized() const {
  return true;
}

void ShapeEntity_EllipseArgs::Swap(ShapeEntity_EllipseArgs* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ShapeEntity_EllipseArgs::InternalSwap(ShapeEntity_EllipseArgs* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(radiusx_, other->radiusx_);
  std::swap(radiusy_, other->radiusy_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ShapeEntity_EllipseArgs::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShapeEntity_EllipseArgs

// float x = 1;
void ShapeEntity_EllipseArgs::clear_x() {
  x_ = 0;
}
float ShapeEntity_EllipseArgs::x() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.x)
  return x_;
}
void ShapeEntity_EllipseArgs::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.x)
}

// float y = 2;
void ShapeEntity_EllipseArgs::clear_y() {
  y_ = 0;
}
float ShapeEntity_EllipseArgs::y() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.y)
  return y_;
}
void ShapeEntity_EllipseArgs::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.y)
}

// float radiusX = 3;
void ShapeEntity_EllipseArgs::clear_radiusx() {
  radiusx_ = 0;
}
float ShapeEntity_EllipseArgs::radiusx() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.radiusX)
  return radiusx_;
}
void ShapeEntity_EllipseArgs::set_radiusx(float value) {
  
  radiusx_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.radiusX)
}

// float radiusY = 4;
void ShapeEntity_EllipseArgs::clear_radiusy() {
  radiusy_ = 0;
}
float ShapeEntity_EllipseArgs::radiusy() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.radiusY)
  return radiusy_;
}
void ShapeEntity_EllipseArgs::set_radiusy(float value) {
  
  radiusy_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.radiusY)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShapeEntity_ShapeStyle_RGBAColor::kRFieldNumber;
const int ShapeEntity_ShapeStyle_RGBAColor::kGFieldNumber;
const int ShapeEntity_ShapeStyle_RGBAColor::kBFieldNumber;
const int ShapeEntity_ShapeStyle_RGBAColor::kAFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ShapeEntity_ShapeStyle_RGBAColor::ShapeEntity_ShapeStyle_RGBAColor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
}
ShapeEntity_ShapeStyle_RGBAColor::ShapeEntity_ShapeStyle_RGBAColor(const ShapeEntity_ShapeStyle_RGBAColor& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&r_, &from.r_,
    reinterpret_cast<char*>(&a_) -
    reinterpret_cast<char*>(&r_) + sizeof(a_));
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
}

void ShapeEntity_ShapeStyle_RGBAColor::SharedCtor() {
  ::memset(&r_, 0, reinterpret_cast<char*>(&a_) -
    reinterpret_cast<char*>(&r_) + sizeof(a_));
  _cached_size_ = 0;
}

ShapeEntity_ShapeStyle_RGBAColor::~ShapeEntity_ShapeStyle_RGBAColor() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  SharedDtor();
}

void ShapeEntity_ShapeStyle_RGBAColor::SharedDtor() {
}

void ShapeEntity_ShapeStyle_RGBAColor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShapeEntity_ShapeStyle_RGBAColor::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ShapeEntity_ShapeStyle_RGBAColor& ShapeEntity_ShapeStyle_RGBAColor::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle_RGBAColor::New(::google::protobuf::Arena* arena) const {
  ShapeEntity_ShapeStyle_RGBAColor* n = new ShapeEntity_ShapeStyle_RGBAColor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ShapeEntity_ShapeStyle_RGBAColor::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  ::memset(&r_, 0, reinterpret_cast<char*>(&a_) -
    reinterpret_cast<char*>(&r_) + sizeof(a_));
}

bool ShapeEntity_ShapeStyle_RGBAColor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float r = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &r_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float g = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &g_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float b = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &b_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float a = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(37u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &a_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  return false;
#undef DO_
}

void ShapeEntity_ShapeStyle_RGBAColor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float r = 1;
  if (this->r() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->r(), output);
  }

  // float g = 2;
  if (this->g() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->g(), output);
  }

  // float b = 3;
  if (this->b() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->b(), output);
  }

  // float a = 4;
  if (this->a() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->a(), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
}

::google::protobuf::uint8* ShapeEntity_ShapeStyle_RGBAColor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float r = 1;
  if (this->r() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->r(), target);
  }

  // float g = 2;
  if (this->g() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->g(), target);
  }

  // float b = 3;
  if (this->b() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->b(), target);
  }

  // float a = 4;
  if (this->a() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->a(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  return target;
}

size_t ShapeEntity_ShapeStyle_RGBAColor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  size_t total_size = 0;

  // float r = 1;
  if (this->r() != 0) {
    total_size += 1 + 4;
  }

  // float g = 2;
  if (this->g() != 0) {
    total_size += 1 + 4;
  }

  // float b = 3;
  if (this->b() != 0) {
    total_size += 1 + 4;
  }

  // float a = 4;
  if (this->a() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShapeEntity_ShapeStyle_RGBAColor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  GOOGLE_DCHECK_NE(&from, this);
  const ShapeEntity_ShapeStyle_RGBAColor* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ShapeEntity_ShapeStyle_RGBAColor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
    MergeFrom(*source);
  }
}

void ShapeEntity_ShapeStyle_RGBAColor::MergeFrom(const ShapeEntity_ShapeStyle_RGBAColor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.r() != 0) {
    set_r(from.r());
  }
  if (from.g() != 0) {
    set_g(from.g());
  }
  if (from.b() != 0) {
    set_b(from.b());
  }
  if (from.a() != 0) {
    set_a(from.a());
  }
}

void ShapeEntity_ShapeStyle_RGBAColor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShapeEntity_ShapeStyle_RGBAColor::CopyFrom(const ShapeEntity_ShapeStyle_RGBAColor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeEntity_ShapeStyle_RGBAColor::IsInitialized() const {
  return true;
}

void ShapeEntity_ShapeStyle_RGBAColor::Swap(ShapeEntity_ShapeStyle_RGBAColor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ShapeEntity_ShapeStyle_RGBAColor::InternalSwap(ShapeEntity_ShapeStyle_RGBAColor* other) {
  std::swap(r_, other->r_);
  std::swap(g_, other->g_);
  std::swap(b_, other->b_);
  std::swap(a_, other->a_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ShapeEntity_ShapeStyle_RGBAColor::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShapeEntity_ShapeStyle_RGBAColor

// float r = 1;
void ShapeEntity_ShapeStyle_RGBAColor::clear_r() {
  r_ = 0;
}
float ShapeEntity_ShapeStyle_RGBAColor::r() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.r)
  return r_;
}
void ShapeEntity_ShapeStyle_RGBAColor::set_r(float value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.r)
}

// float g = 2;
void ShapeEntity_ShapeStyle_RGBAColor::clear_g() {
  g_ = 0;
}
float ShapeEntity_ShapeStyle_RGBAColor::g() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.g)
  return g_;
}
void ShapeEntity_ShapeStyle_RGBAColor::set_g(float value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.g)
}

// float b = 3;
void ShapeEntity_ShapeStyle_RGBAColor::clear_b() {
  b_ = 0;
}
float ShapeEntity_ShapeStyle_RGBAColor::b() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.b)
  return b_;
}
void ShapeEntity_ShapeStyle_RGBAColor::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.b)
}

// float a = 4;
void ShapeEntity_ShapeStyle_RGBAColor::clear_a() {
  a_ = 0;
}
float ShapeEntity_ShapeStyle_RGBAColor::a() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.a)
  return a_;
}
void ShapeEntity_ShapeStyle_RGBAColor::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.a)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShapeEntity_ShapeStyle::kFillFieldNumber;
const int ShapeEntity_ShapeStyle::kStrokeFieldNumber;
const int ShapeEntity_ShapeStyle::kStrokeWidthFieldNumber;
const int ShapeEntity_ShapeStyle::kLineCapFieldNumber;
const int ShapeEntity_ShapeStyle::kLineJoinFieldNumber;
const int ShapeEntity_ShapeStyle::kMiterLimitFieldNumber;
const int ShapeEntity_ShapeStyle::kLineDashIFieldNumber;
const int ShapeEntity_ShapeStyle::kLineDashIIFieldNumber;
const int ShapeEntity_ShapeStyle::kLineDashIIIFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ShapeEntity_ShapeStyle::ShapeEntity_ShapeStyle()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.ShapeEntity.ShapeStyle)
}
ShapeEntity_ShapeStyle::ShapeEntity_ShapeStyle(const ShapeEntity_ShapeStyle& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_fill()) {
    fill_ = new ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor(*from.fill_);
  } else {
    fill_ = NULL;
  }
  if (from.has_stroke()) {
    stroke_ = new ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor(*from.stroke_);
  } else {
    stroke_ = NULL;
  }
  ::memcpy(&strokewidth_, &from.strokewidth_,
    reinterpret_cast<char*>(&linedashiii_) -
    reinterpret_cast<char*>(&strokewidth_) + sizeof(linedashiii_));
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.ShapeEntity.ShapeStyle)
}

void ShapeEntity_ShapeStyle::SharedCtor() {
  ::memset(&fill_, 0, reinterpret_cast<char*>(&linedashiii_) -
    reinterpret_cast<char*>(&fill_) + sizeof(linedashiii_));
  _cached_size_ = 0;
}

ShapeEntity_ShapeStyle::~ShapeEntity_ShapeStyle() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.ShapeEntity.ShapeStyle)
  SharedDtor();
}

void ShapeEntity_ShapeStyle::SharedDtor() {
  if (this != internal_default_instance()) {
    delete fill_;
  }
  if (this != internal_default_instance()) {
    delete stroke_;
  }
}

void ShapeEntity_ShapeStyle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShapeEntity_ShapeStyle::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ShapeEntity_ShapeStyle& ShapeEntity_ShapeStyle::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

ShapeEntity_ShapeStyle* ShapeEntity_ShapeStyle::New(::google::protobuf::Arena* arena) const {
  ShapeEntity_ShapeStyle* n = new ShapeEntity_ShapeStyle;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ShapeEntity_ShapeStyle::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.ShapeEntity.ShapeStyle)
  if (GetArenaNoVirtual() == NULL && fill_ != NULL) {
    delete fill_;
  }
  fill_ = NULL;
  if (GetArenaNoVirtual() == NULL && stroke_ != NULL) {
    delete stroke_;
  }
  stroke_ = NULL;
  ::memset(&strokewidth_, 0, reinterpret_cast<char*>(&linedashiii_) -
    reinterpret_cast<char*>(&strokewidth_) + sizeof(linedashiii_));
}

bool ShapeEntity_ShapeStyle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.ShapeEntity.ShapeStyle)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor fill = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fill()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor stroke = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stroke()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float strokeWidth = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &strokewidth_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.ShapeEntity.ShapeStyle.LineCap lineCap = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_linecap(static_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin lineJoin = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_linejoin(static_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float miterLimit = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(53u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &miterlimit_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float lineDashI = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(61u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &linedashi_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float lineDashII = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(69u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &linedashii_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float lineDashIII = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(77u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &linedashiii_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.ShapeEntity.ShapeStyle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.ShapeEntity.ShapeStyle)
  return false;
#undef DO_
}

void ShapeEntity_ShapeStyle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.ShapeEntity.ShapeStyle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor fill = 1;
  if (this->has_fill()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->fill_, output);
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor stroke = 2;
  if (this->has_stroke()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->stroke_, output);
  }

  // float strokeWidth = 3;
  if (this->strokewidth() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->strokewidth(), output);
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineCap lineCap = 4;
  if (this->linecap() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->linecap(), output);
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin lineJoin = 5;
  if (this->linejoin() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->linejoin(), output);
  }

  // float miterLimit = 6;
  if (this->miterlimit() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->miterlimit(), output);
  }

  // float lineDashI = 7;
  if (this->linedashi() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->linedashi(), output);
  }

  // float lineDashII = 8;
  if (this->linedashii() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->linedashii(), output);
  }

  // float lineDashIII = 9;
  if (this->linedashiii() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->linedashiii(), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.ShapeEntity.ShapeStyle)
}

::google::protobuf::uint8* ShapeEntity_ShapeStyle::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.ShapeEntity.ShapeStyle)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor fill = 1;
  if (this->has_fill()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->fill_, deterministic, target);
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor stroke = 2;
  if (this->has_stroke()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->stroke_, deterministic, target);
  }

  // float strokeWidth = 3;
  if (this->strokewidth() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->strokewidth(), target);
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineCap lineCap = 4;
  if (this->linecap() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->linecap(), target);
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin lineJoin = 5;
  if (this->linejoin() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->linejoin(), target);
  }

  // float miterLimit = 6;
  if (this->miterlimit() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->miterlimit(), target);
  }

  // float lineDashI = 7;
  if (this->linedashi() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->linedashi(), target);
  }

  // float lineDashII = 8;
  if (this->linedashii() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->linedashii(), target);
  }

  // float lineDashIII = 9;
  if (this->linedashiii() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->linedashiii(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.ShapeEntity.ShapeStyle)
  return target;
}

size_t ShapeEntity_ShapeStyle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.ShapeEntity.ShapeStyle)
  size_t total_size = 0;

  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor fill = 1;
  if (this->has_fill()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->fill_);
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor stroke = 2;
  if (this->has_stroke()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->stroke_);
  }

  // float strokeWidth = 3;
  if (this->strokewidth() != 0) {
    total_size += 1 + 4;
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineCap lineCap = 4;
  if (this->linecap() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->linecap());
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin lineJoin = 5;
  if (this->linejoin() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->linejoin());
  }

  // float miterLimit = 6;
  if (this->miterlimit() != 0) {
    total_size += 1 + 4;
  }

  // float lineDashI = 7;
  if (this->linedashi() != 0) {
    total_size += 1 + 4;
  }

  // float lineDashII = 8;
  if (this->linedashii() != 0) {
    total_size += 1 + 4;
  }

  // float lineDashIII = 9;
  if (this->linedashiii() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShapeEntity_ShapeStyle::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.ShapeEntity.ShapeStyle)
  GOOGLE_DCHECK_NE(&from, this);
  const ShapeEntity_ShapeStyle* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ShapeEntity_ShapeStyle>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.ShapeEntity.ShapeStyle)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.ShapeEntity.ShapeStyle)
    MergeFrom(*source);
  }
}

void ShapeEntity_ShapeStyle::MergeFrom(const ShapeEntity_ShapeStyle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.ShapeEntity.ShapeStyle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_fill()) {
    mutable_fill()->::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor::MergeFrom(from.fill());
  }
  if (from.has_stroke()) {
    mutable_stroke()->::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor::MergeFrom(from.stroke());
  }
  if (from.strokewidth() != 0) {
    set_strokewidth(from.strokewidth());
  }
  if (from.linecap() != 0) {
    set_linecap(from.linecap());
  }
  if (from.linejoin() != 0) {
    set_linejoin(from.linejoin());
  }
  if (from.miterlimit() != 0) {
    set_miterlimit(from.miterlimit());
  }
  if (from.linedashi() != 0) {
    set_linedashi(from.linedashi());
  }
  if (from.linedashii() != 0) {
    set_linedashii(from.linedashii());
  }
  if (from.linedashiii() != 0) {
    set_linedashiii(from.linedashiii());
  }
}

void ShapeEntity_ShapeStyle::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.ShapeEntity.ShapeStyle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShapeEntity_ShapeStyle::CopyFrom(const ShapeEntity_ShapeStyle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.ShapeEntity.ShapeStyle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeEntity_ShapeStyle::IsInitialized() const {
  return true;
}

void ShapeEntity_ShapeStyle::Swap(ShapeEntity_ShapeStyle* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ShapeEntity_ShapeStyle::InternalSwap(ShapeEntity_ShapeStyle* other) {
  std::swap(fill_, other->fill_);
  std::swap(stroke_, other->stroke_);
  std::swap(strokewidth_, other->strokewidth_);
  std::swap(linecap_, other->linecap_);
  std::swap(linejoin_, other->linejoin_);
  std::swap(miterlimit_, other->miterlimit_);
  std::swap(linedashi_, other->linedashi_);
  std::swap(linedashii_, other->linedashii_);
  std::swap(linedashiii_, other->linedashiii_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ShapeEntity_ShapeStyle::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShapeEntity_ShapeStyle

// .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor fill = 1;
bool ShapeEntity_ShapeStyle::has_fill() const {
  return this != internal_default_instance() && fill_ != NULL;
}
void ShapeEntity_ShapeStyle::clear_fill() {
  if (GetArenaNoVirtual() == NULL && fill_ != NULL) delete fill_;
  fill_ = NULL;
}
const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& ShapeEntity_ShapeStyle::fill() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
  return fill_ != NULL ? *fill_
                         : *::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor::internal_default_instance();
}
::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::mutable_fill() {
  
  if (fill_ == NULL) {
    fill_ = new ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
  return fill_;
}
::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::release_fill() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* temp = fill_;
  fill_ = NULL;
  return temp;
}
void ShapeEntity_ShapeStyle::set_allocated_fill(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* fill) {
  delete fill_;
  fill_ = fill;
  if (fill) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor stroke = 2;
bool ShapeEntity_ShapeStyle::has_stroke() const {
  return this != internal_default_instance() && stroke_ != NULL;
}
void ShapeEntity_ShapeStyle::clear_stroke() {
  if (GetArenaNoVirtual() == NULL && stroke_ != NULL) delete stroke_;
  stroke_ = NULL;
}
const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& ShapeEntity_ShapeStyle::stroke() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
  return stroke_ != NULL ? *stroke_
                         : *::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor::internal_default_instance();
}
::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::mutable_stroke() {
  
  if (stroke_ == NULL) {
    stroke_ = new ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
  return stroke_;
}
::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::release_stroke() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* temp = stroke_;
  stroke_ = NULL;
  return temp;
}
void ShapeEntity_ShapeStyle::set_allocated_stroke(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* stroke) {
  delete stroke_;
  stroke_ = stroke;
  if (stroke) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
}

// float strokeWidth = 3;
void ShapeEntity_ShapeStyle::clear_strokewidth() {
  strokewidth_ = 0;
}
float ShapeEntity_ShapeStyle::strokewidth() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.strokeWidth)
  return strokewidth_;
}
void ShapeEntity_ShapeStyle::set_strokewidth(float value) {
  
  strokewidth_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.strokeWidth)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle.LineCap lineCap = 4;
void ShapeEntity_ShapeStyle::clear_linecap() {
  linecap_ = 0;
}
::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle::linecap() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineCap)
  return static_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap >(linecap_);
}
void ShapeEntity_ShapeStyle::set_linecap(::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap value) {
  
  linecap_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineCap)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin lineJoin = 5;
void ShapeEntity_ShapeStyle::clear_linejoin() {
  linejoin_ = 0;
}
::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle::linejoin() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineJoin)
  return static_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin >(linejoin_);
}
void ShapeEntity_ShapeStyle::set_linejoin(::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin value) {
  
  linejoin_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineJoin)
}

// float miterLimit = 6;
void ShapeEntity_ShapeStyle::clear_miterlimit() {
  miterlimit_ = 0;
}
float ShapeEntity_ShapeStyle::miterlimit() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.miterLimit)
  return miterlimit_;
}
void ShapeEntity_ShapeStyle::set_miterlimit(float value) {
  
  miterlimit_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.miterLimit)
}

// float lineDashI = 7;
void ShapeEntity_ShapeStyle::clear_linedashi() {
  linedashi_ = 0;
}
float ShapeEntity_ShapeStyle::linedashi() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashI)
  return linedashi_;
}
void ShapeEntity_ShapeStyle::set_linedashi(float value) {
  
  linedashi_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashI)
}

// float lineDashII = 8;
void ShapeEntity_ShapeStyle::clear_linedashii() {
  linedashii_ = 0;
}
float ShapeEntity_ShapeStyle::linedashii() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashII)
  return linedashii_;
}
void ShapeEntity_ShapeStyle::set_linedashii(float value) {
  
  linedashii_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashII)
}

// float lineDashIII = 9;
void ShapeEntity_ShapeStyle::clear_linedashiii() {
  linedashiii_ = 0;
}
float ShapeEntity_ShapeStyle::linedashiii() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashIII)
  return linedashiii_;
}
void ShapeEntity_ShapeStyle::set_linedashiii(float value) {
  
  linedashiii_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashIII)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ShapeEntity::kTypeFieldNumber;
const int ShapeEntity::kShapeFieldNumber;
const int ShapeEntity::kRectFieldNumber;
const int ShapeEntity::kEllipseFieldNumber;
const int ShapeEntity::kStylesFieldNumber;
const int ShapeEntity::kTransformFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ShapeEntity::ShapeEntity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.ShapeEntity)
}
ShapeEntity::ShapeEntity(const ShapeEntity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_styles()) {
    styles_ = new ::com::opensource::svga::ShapeEntity_ShapeStyle(*from.styles_);
  } else {
    styles_ = NULL;
  }
  if (from.has_transform()) {
    transform_ = new ::com::opensource::svga::Transform(*from.transform_);
  } else {
    transform_ = NULL;
  }
  type_ = from.type_;
  clear_has_args();
  switch (from.args_case()) {
    case kShape: {
      mutable_shape()->::com::opensource::svga::ShapeEntity_ShapeArgs::MergeFrom(from.shape());
      break;
    }
    case kRect: {
      mutable_rect()->::com::opensource::svga::ShapeEntity_RectArgs::MergeFrom(from.rect());
      break;
    }
    case kEllipse: {
      mutable_ellipse()->::com::opensource::svga::ShapeEntity_EllipseArgs::MergeFrom(from.ellipse());
      break;
    }
    case ARGS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.ShapeEntity)
}

void ShapeEntity::SharedCtor() {
  ::memset(&styles_, 0, reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&styles_) + sizeof(type_));
  clear_has_args();
  _cached_size_ = 0;
}

ShapeEntity::~ShapeEntity() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.ShapeEntity)
  SharedDtor();
}

void ShapeEntity::SharedDtor() {
  if (this != internal_default_instance()) {
    delete styles_;
  }
  if (this != internal_default_instance()) {
    delete transform_;
  }
  if (has_args()) {
    clear_args();
  }
}

void ShapeEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShapeEntity::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ShapeEntity& ShapeEntity::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

ShapeEntity* ShapeEntity::New(::google::protobuf::Arena* arena) const {
  ShapeEntity* n = new ShapeEntity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ShapeEntity::clear_args() {
// @@protoc_insertion_point(one_of_clear_start:com.opensource.svga.ShapeEntity)
  switch (args_case()) {
    case kShape: {
      delete args_.shape_;
      break;
    }
    case kRect: {
      delete args_.rect_;
      break;
    }
    case kEllipse: {
      delete args_.ellipse_;
      break;
    }
    case ARGS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ARGS_NOT_SET;
}


void ShapeEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.ShapeEntity)
  if (GetArenaNoVirtual() == NULL && styles_ != NULL) {
    delete styles_;
  }
  styles_ = NULL;
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) {
    delete transform_;
  }
  transform_ = NULL;
  type_ = 0;
  clear_args();
}

bool ShapeEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.ShapeEntity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .com.opensource.svga.ShapeEntity.ShapeType type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::com::opensource::svga::ShapeEntity_ShapeType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.ShapeEntity.ShapeArgs shape = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shape()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.ShapeEntity.RectArgs rect = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rect()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.ShapeEntity.EllipseArgs ellipse = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ellipse()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.ShapeEntity.ShapeStyle styles = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_styles()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.Transform transform = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transform()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.ShapeEntity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.ShapeEntity)
  return false;
#undef DO_
}

void ShapeEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.ShapeEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .com.opensource.svga.ShapeEntity.ShapeType type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // .com.opensource.svga.ShapeEntity.ShapeArgs shape = 2;
  if (has_shape()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *args_.shape_, output);
  }

  // .com.opensource.svga.ShapeEntity.RectArgs rect = 3;
  if (has_rect()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *args_.rect_, output);
  }

  // .com.opensource.svga.ShapeEntity.EllipseArgs ellipse = 4;
  if (has_ellipse()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *args_.ellipse_, output);
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle styles = 10;
  if (this->has_styles()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->styles_, output);
  }

  // .com.opensource.svga.Transform transform = 11;
  if (this->has_transform()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->transform_, output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.ShapeEntity)
}

::google::protobuf::uint8* ShapeEntity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.ShapeEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .com.opensource.svga.ShapeEntity.ShapeType type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // .com.opensource.svga.ShapeEntity.ShapeArgs shape = 2;
  if (has_shape()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *args_.shape_, deterministic, target);
  }

  // .com.opensource.svga.ShapeEntity.RectArgs rect = 3;
  if (has_rect()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *args_.rect_, deterministic, target);
  }

  // .com.opensource.svga.ShapeEntity.EllipseArgs ellipse = 4;
  if (has_ellipse()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *args_.ellipse_, deterministic, target);
  }

  // .com.opensource.svga.ShapeEntity.ShapeStyle styles = 10;
  if (this->has_styles()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *this->styles_, deterministic, target);
  }

  // .com.opensource.svga.Transform transform = 11;
  if (this->has_transform()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->transform_, deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.ShapeEntity)
  return target;
}

size_t ShapeEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.ShapeEntity)
  size_t total_size = 0;

  // .com.opensource.svga.ShapeEntity.ShapeStyle styles = 10;
  if (this->has_styles()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->styles_);
  }

  // .com.opensource.svga.Transform transform = 11;
  if (this->has_transform()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->transform_);
  }

  // .com.opensource.svga.ShapeEntity.ShapeType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  switch (args_case()) {
    // .com.opensource.svga.ShapeEntity.ShapeArgs shape = 2;
    case kShape: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *args_.shape_);
      break;
    }
    // .com.opensource.svga.ShapeEntity.RectArgs rect = 3;
    case kRect: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *args_.rect_);
      break;
    }
    // .com.opensource.svga.ShapeEntity.EllipseArgs ellipse = 4;
    case kEllipse: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *args_.ellipse_);
      break;
    }
    case ARGS_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShapeEntity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.ShapeEntity)
  GOOGLE_DCHECK_NE(&from, this);
  const ShapeEntity* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ShapeEntity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.ShapeEntity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.ShapeEntity)
    MergeFrom(*source);
  }
}

void ShapeEntity::MergeFrom(const ShapeEntity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.ShapeEntity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_styles()) {
    mutable_styles()->::com::opensource::svga::ShapeEntity_ShapeStyle::MergeFrom(from.styles());
  }
  if (from.has_transform()) {
    mutable_transform()->::com::opensource::svga::Transform::MergeFrom(from.transform());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  switch (from.args_case()) {
    case kShape: {
      mutable_shape()->::com::opensource::svga::ShapeEntity_ShapeArgs::MergeFrom(from.shape());
      break;
    }
    case kRect: {
      mutable_rect()->::com::opensource::svga::ShapeEntity_RectArgs::MergeFrom(from.rect());
      break;
    }
    case kEllipse: {
      mutable_ellipse()->::com::opensource::svga::ShapeEntity_EllipseArgs::MergeFrom(from.ellipse());
      break;
    }
    case ARGS_NOT_SET: {
      break;
    }
  }
}

void ShapeEntity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.ShapeEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShapeEntity::CopyFrom(const ShapeEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.ShapeEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShapeEntity::IsInitialized() const {
  return true;
}

void ShapeEntity::Swap(ShapeEntity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ShapeEntity::InternalSwap(ShapeEntity* other) {
  std::swap(styles_, other->styles_);
  std::swap(transform_, other->transform_);
  std::swap(type_, other->type_);
  std::swap(args_, other->args_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ShapeEntity::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ShapeEntity

// .com.opensource.svga.ShapeEntity.ShapeType type = 1;
void ShapeEntity::clear_type() {
  type_ = 0;
}
::com::opensource::svga::ShapeEntity_ShapeType ShapeEntity::type() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.type)
  return static_cast< ::com::opensource::svga::ShapeEntity_ShapeType >(type_);
}
void ShapeEntity::set_type(::com::opensource::svga::ShapeEntity_ShapeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.type)
}

// .com.opensource.svga.ShapeEntity.ShapeArgs shape = 2;
bool ShapeEntity::has_shape() const {
  return args_case() == kShape;
}
void ShapeEntity::set_has_shape() {
  _oneof_case_[0] = kShape;
}
void ShapeEntity::clear_shape() {
  if (has_shape()) {
    delete args_.shape_;
    clear_has_args();
  }
}
 const ::com::opensource::svga::ShapeEntity_ShapeArgs& ShapeEntity::shape() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.shape)
  return has_shape()
      ? *args_.shape_
      : ::com::opensource::svga::ShapeEntity_ShapeArgs::default_instance();
}
::com::opensource::svga::ShapeEntity_ShapeArgs* ShapeEntity::mutable_shape() {
  if (!has_shape()) {
    clear_args();
    set_has_shape();
    args_.shape_ = new ::com::opensource::svga::ShapeEntity_ShapeArgs;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.shape)
  return args_.shape_;
}
::com::opensource::svga::ShapeEntity_ShapeArgs* ShapeEntity::release_shape() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.shape)
  if (has_shape()) {
    clear_has_args();
    ::com::opensource::svga::ShapeEntity_ShapeArgs* temp = args_.shape_;
    args_.shape_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ShapeEntity::set_allocated_shape(::com::opensource::svga::ShapeEntity_ShapeArgs* shape) {
  clear_args();
  if (shape) {
    set_has_shape();
    args_.shape_ = shape;
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.shape)
}

// .com.opensource.svga.ShapeEntity.RectArgs rect = 3;
bool ShapeEntity::has_rect() const {
  return args_case() == kRect;
}
void ShapeEntity::set_has_rect() {
  _oneof_case_[0] = kRect;
}
void ShapeEntity::clear_rect() {
  if (has_rect()) {
    delete args_.rect_;
    clear_has_args();
  }
}
 const ::com::opensource::svga::ShapeEntity_RectArgs& ShapeEntity::rect() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.rect)
  return has_rect()
      ? *args_.rect_
      : ::com::opensource::svga::ShapeEntity_RectArgs::default_instance();
}
::com::opensource::svga::ShapeEntity_RectArgs* ShapeEntity::mutable_rect() {
  if (!has_rect()) {
    clear_args();
    set_has_rect();
    args_.rect_ = new ::com::opensource::svga::ShapeEntity_RectArgs;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.rect)
  return args_.rect_;
}
::com::opensource::svga::ShapeEntity_RectArgs* ShapeEntity::release_rect() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.rect)
  if (has_rect()) {
    clear_has_args();
    ::com::opensource::svga::ShapeEntity_RectArgs* temp = args_.rect_;
    args_.rect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ShapeEntity::set_allocated_rect(::com::opensource::svga::ShapeEntity_RectArgs* rect) {
  clear_args();
  if (rect) {
    set_has_rect();
    args_.rect_ = rect;
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.rect)
}

// .com.opensource.svga.ShapeEntity.EllipseArgs ellipse = 4;
bool ShapeEntity::has_ellipse() const {
  return args_case() == kEllipse;
}
void ShapeEntity::set_has_ellipse() {
  _oneof_case_[0] = kEllipse;
}
void ShapeEntity::clear_ellipse() {
  if (has_ellipse()) {
    delete args_.ellipse_;
    clear_has_args();
  }
}
 const ::com::opensource::svga::ShapeEntity_EllipseArgs& ShapeEntity::ellipse() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ellipse)
  return has_ellipse()
      ? *args_.ellipse_
      : ::com::opensource::svga::ShapeEntity_EllipseArgs::default_instance();
}
::com::opensource::svga::ShapeEntity_EllipseArgs* ShapeEntity::mutable_ellipse() {
  if (!has_ellipse()) {
    clear_args();
    set_has_ellipse();
    args_.ellipse_ = new ::com::opensource::svga::ShapeEntity_EllipseArgs;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ellipse)
  return args_.ellipse_;
}
::com::opensource::svga::ShapeEntity_EllipseArgs* ShapeEntity::release_ellipse() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ellipse)
  if (has_ellipse()) {
    clear_has_args();
    ::com::opensource::svga::ShapeEntity_EllipseArgs* temp = args_.ellipse_;
    args_.ellipse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ShapeEntity::set_allocated_ellipse(::com::opensource::svga::ShapeEntity_EllipseArgs* ellipse) {
  clear_args();
  if (ellipse) {
    set_has_ellipse();
    args_.ellipse_ = ellipse;
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ellipse)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle styles = 10;
bool ShapeEntity::has_styles() const {
  return this != internal_default_instance() && styles_ != NULL;
}
void ShapeEntity::clear_styles() {
  if (GetArenaNoVirtual() == NULL && styles_ != NULL) delete styles_;
  styles_ = NULL;
}
const ::com::opensource::svga::ShapeEntity_ShapeStyle& ShapeEntity::styles() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.styles)
  return styles_ != NULL ? *styles_
                         : *::com::opensource::svga::ShapeEntity_ShapeStyle::internal_default_instance();
}
::com::opensource::svga::ShapeEntity_ShapeStyle* ShapeEntity::mutable_styles() {
  
  if (styles_ == NULL) {
    styles_ = new ::com::opensource::svga::ShapeEntity_ShapeStyle;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.styles)
  return styles_;
}
::com::opensource::svga::ShapeEntity_ShapeStyle* ShapeEntity::release_styles() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.styles)
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle* temp = styles_;
  styles_ = NULL;
  return temp;
}
void ShapeEntity::set_allocated_styles(::com::opensource::svga::ShapeEntity_ShapeStyle* styles) {
  delete styles_;
  styles_ = styles;
  if (styles) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.styles)
}

// .com.opensource.svga.Transform transform = 11;
bool ShapeEntity::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
void ShapeEntity::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) delete transform_;
  transform_ = NULL;
}
const ::com::opensource::svga::Transform& ShapeEntity::transform() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.transform)
  return transform_ != NULL ? *transform_
                         : *::com::opensource::svga::Transform::internal_default_instance();
}
::com::opensource::svga::Transform* ShapeEntity::mutable_transform() {
  
  if (transform_ == NULL) {
    transform_ = new ::com::opensource::svga::Transform;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.transform)
  return transform_;
}
::com::opensource::svga::Transform* ShapeEntity::release_transform() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.transform)
  
  ::com::opensource::svga::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
void ShapeEntity::set_allocated_transform(::com::opensource::svga::Transform* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.transform)
}

bool ShapeEntity::has_args() const {
  return args_case() != ARGS_NOT_SET;
}
void ShapeEntity::clear_has_args() {
  _oneof_case_[0] = ARGS_NOT_SET;
}
ShapeEntity::ArgsCase ShapeEntity::args_case() const {
  return ShapeEntity::ArgsCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FrameEntity::kAlphaFieldNumber;
const int FrameEntity::kLayoutFieldNumber;
const int FrameEntity::kTransformFieldNumber;
const int FrameEntity::kClipPathFieldNumber;
const int FrameEntity::kShapesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FrameEntity::FrameEntity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.FrameEntity)
}
FrameEntity::FrameEntity(const FrameEntity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      shapes_(from.shapes_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clippath_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.clippath().size() > 0) {
    clippath_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clippath_);
  }
  if (from.has_layout()) {
    layout_ = new ::com::opensource::svga::Layout(*from.layout_);
  } else {
    layout_ = NULL;
  }
  if (from.has_transform()) {
    transform_ = new ::com::opensource::svga::Transform(*from.transform_);
  } else {
    transform_ = NULL;
  }
  alpha_ = from.alpha_;
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.FrameEntity)
}

void FrameEntity::SharedCtor() {
  clippath_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&layout_, 0, reinterpret_cast<char*>(&alpha_) -
    reinterpret_cast<char*>(&layout_) + sizeof(alpha_));
  _cached_size_ = 0;
}

FrameEntity::~FrameEntity() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.FrameEntity)
  SharedDtor();
}

void FrameEntity::SharedDtor() {
  clippath_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete layout_;
  }
  if (this != internal_default_instance()) {
    delete transform_;
  }
}

void FrameEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameEntity::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const FrameEntity& FrameEntity::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

FrameEntity* FrameEntity::New(::google::protobuf::Arena* arena) const {
  FrameEntity* n = new FrameEntity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FrameEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.FrameEntity)
  shapes_.Clear();
  clippath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && layout_ != NULL) {
    delete layout_;
  }
  layout_ = NULL;
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) {
    delete transform_;
  }
  transform_ = NULL;
  alpha_ = 0;
}

bool FrameEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.FrameEntity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float alpha = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(13u)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &alpha_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.Layout layout = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_layout()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.Transform transform = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_transform()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string clipPath = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clippath()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->clippath().data(), this->clippath().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "com.opensource.svga.FrameEntity.clipPath"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .com.opensource.svga.ShapeEntity shapes = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shapes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.FrameEntity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.FrameEntity)
  return false;
#undef DO_
}

void FrameEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.FrameEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  if (this->alpha() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->alpha(), output);
  }

  // .com.opensource.svga.Layout layout = 2;
  if (this->has_layout()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->layout_, output);
  }

  // .com.opensource.svga.Transform transform = 3;
  if (this->has_transform()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->transform_, output);
  }

  // string clipPath = 4;
  if (this->clippath().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->clippath().data(), this->clippath().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.FrameEntity.clipPath");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->clippath(), output);
  }

  // repeated .com.opensource.svga.ShapeEntity shapes = 5;
  for (unsigned int i = 0, n = this->shapes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->shapes(i), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.FrameEntity)
}

::google::protobuf::uint8* FrameEntity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.FrameEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float alpha = 1;
  if (this->alpha() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->alpha(), target);
  }

  // .com.opensource.svga.Layout layout = 2;
  if (this->has_layout()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->layout_, deterministic, target);
  }

  // .com.opensource.svga.Transform transform = 3;
  if (this->has_transform()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->transform_, deterministic, target);
  }

  // string clipPath = 4;
  if (this->clippath().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->clippath().data(), this->clippath().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.FrameEntity.clipPath");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->clippath(), target);
  }

  // repeated .com.opensource.svga.ShapeEntity shapes = 5;
  for (unsigned int i = 0, n = this->shapes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->shapes(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.FrameEntity)
  return target;
}

size_t FrameEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.FrameEntity)
  size_t total_size = 0;

  // repeated .com.opensource.svga.ShapeEntity shapes = 5;
  {
    unsigned int count = this->shapes_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->shapes(i));
    }
  }

  // string clipPath = 4;
  if (this->clippath().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->clippath());
  }

  // .com.opensource.svga.Layout layout = 2;
  if (this->has_layout()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->layout_);
  }

  // .com.opensource.svga.Transform transform = 3;
  if (this->has_transform()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->transform_);
  }

  // float alpha = 1;
  if (this->alpha() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameEntity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.FrameEntity)
  GOOGLE_DCHECK_NE(&from, this);
  const FrameEntity* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const FrameEntity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.FrameEntity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.FrameEntity)
    MergeFrom(*source);
  }
}

void FrameEntity::MergeFrom(const FrameEntity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.FrameEntity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  shapes_.MergeFrom(from.shapes_);
  if (from.clippath().size() > 0) {

    clippath_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.clippath_);
  }
  if (from.has_layout()) {
    mutable_layout()->::com::opensource::svga::Layout::MergeFrom(from.layout());
  }
  if (from.has_transform()) {
    mutable_transform()->::com::opensource::svga::Transform::MergeFrom(from.transform());
  }
  if (from.alpha() != 0) {
    set_alpha(from.alpha());
  }
}

void FrameEntity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.FrameEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameEntity::CopyFrom(const FrameEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.FrameEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameEntity::IsInitialized() const {
  return true;
}

void FrameEntity::Swap(FrameEntity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FrameEntity::InternalSwap(FrameEntity* other) {
  shapes_.InternalSwap(&other->shapes_);
  clippath_.Swap(&other->clippath_);
  std::swap(layout_, other->layout_);
  std::swap(transform_, other->transform_);
  std::swap(alpha_, other->alpha_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FrameEntity::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FrameEntity

// float alpha = 1;
void FrameEntity::clear_alpha() {
  alpha_ = 0;
}
float FrameEntity::alpha() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.alpha)
  return alpha_;
}
void FrameEntity::set_alpha(float value) {
  
  alpha_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.FrameEntity.alpha)
}

// .com.opensource.svga.Layout layout = 2;
bool FrameEntity::has_layout() const {
  return this != internal_default_instance() && layout_ != NULL;
}
void FrameEntity::clear_layout() {
  if (GetArenaNoVirtual() == NULL && layout_ != NULL) delete layout_;
  layout_ = NULL;
}
const ::com::opensource::svga::Layout& FrameEntity::layout() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.layout)
  return layout_ != NULL ? *layout_
                         : *::com::opensource::svga::Layout::internal_default_instance();
}
::com::opensource::svga::Layout* FrameEntity::mutable_layout() {
  
  if (layout_ == NULL) {
    layout_ = new ::com::opensource::svga::Layout;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.layout)
  return layout_;
}
::com::opensource::svga::Layout* FrameEntity::release_layout() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.FrameEntity.layout)
  
  ::com::opensource::svga::Layout* temp = layout_;
  layout_ = NULL;
  return temp;
}
void FrameEntity::set_allocated_layout(::com::opensource::svga::Layout* layout) {
  delete layout_;
  layout_ = layout;
  if (layout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.FrameEntity.layout)
}

// .com.opensource.svga.Transform transform = 3;
bool FrameEntity::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
void FrameEntity::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) delete transform_;
  transform_ = NULL;
}
const ::com::opensource::svga::Transform& FrameEntity::transform() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.transform)
  return transform_ != NULL ? *transform_
                         : *::com::opensource::svga::Transform::internal_default_instance();
}
::com::opensource::svga::Transform* FrameEntity::mutable_transform() {
  
  if (transform_ == NULL) {
    transform_ = new ::com::opensource::svga::Transform;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.transform)
  return transform_;
}
::com::opensource::svga::Transform* FrameEntity::release_transform() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.FrameEntity.transform)
  
  ::com::opensource::svga::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
void FrameEntity::set_allocated_transform(::com::opensource::svga::Transform* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.FrameEntity.transform)
}

// string clipPath = 4;
void FrameEntity::clear_clippath() {
  clippath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& FrameEntity::clippath() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.clipPath)
  return clippath_.GetNoArena();
}
void FrameEntity::set_clippath(const ::std::string& value) {
  
  clippath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.FrameEntity.clipPath)
}
#if LANG_CXX11
void FrameEntity::set_clippath(::std::string&& value) {
  
  clippath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.FrameEntity.clipPath)
}
#endif
void FrameEntity::set_clippath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clippath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.FrameEntity.clipPath)
}
void FrameEntity::set_clippath(const char* value, size_t size) {
  
  clippath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.FrameEntity.clipPath)
}
::std::string* FrameEntity::mutable_clippath() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.clipPath)
  return clippath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FrameEntity::release_clippath() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.FrameEntity.clipPath)
  
  return clippath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FrameEntity::set_allocated_clippath(::std::string* clippath) {
  if (clippath != NULL) {
    
  } else {
    
  }
  clippath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clippath);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.FrameEntity.clipPath)
}

// repeated .com.opensource.svga.ShapeEntity shapes = 5;
int FrameEntity::shapes_size() const {
  return shapes_.size();
}
void FrameEntity::clear_shapes() {
  shapes_.Clear();
}
const ::com::opensource::svga::ShapeEntity& FrameEntity::shapes(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.shapes)
  return shapes_.Get(index);
}
::com::opensource::svga::ShapeEntity* FrameEntity::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.shapes)
  return shapes_.Mutable(index);
}
::com::opensource::svga::ShapeEntity* FrameEntity::add_shapes() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.FrameEntity.shapes)
  return shapes_.Add();
}
::google::protobuf::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >*
FrameEntity::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.FrameEntity.shapes)
  return &shapes_;
}
const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >&
FrameEntity::shapes() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.FrameEntity.shapes)
  return shapes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

MovieEntity::MovieEntity_ImagesEntry::MovieEntity_ImagesEntry() {}
MovieEntity::MovieEntity_ImagesEntry::MovieEntity_ImagesEntry(::google::protobuf::Arena* arena) : SuperType(arena) {}
::google::protobuf::Metadata MovieEntity::MovieEntity_ImagesEntry::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[12];
}
void MovieEntity::MovieEntity_ImagesEntry::MergeFrom(
    const ::google::protobuf::Message& other) {
  ::google::protobuf::Message::MergeFrom(other);
}
void MovieEntity::MovieEntity_ImagesEntry::MergeFrom(const MovieEntity_ImagesEntry& other) {
  MergeFromInternal(other);
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MovieEntity::kVersionFieldNumber;
const int MovieEntity::kParamsFieldNumber;
const int MovieEntity::kImagesFieldNumber;
const int MovieEntity::kSpritesFieldNumber;
const int MovieEntity::kAudiosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MovieEntity::MovieEntity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_svga_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.opensource.svga.MovieEntity)
}
MovieEntity::MovieEntity(const MovieEntity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      sprites_(from.sprites_),
      audios_(from.audios_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  images_.MergeFrom(from.images_);
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.version().size() > 0) {
    version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  if (from.has_params()) {
    params_ = new ::com::opensource::svga::MovieParams(*from.params_);
  } else {
    params_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:com.opensource.svga.MovieEntity)
}

void MovieEntity::SharedCtor() {
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  params_ = NULL;
  _cached_size_ = 0;
}

MovieEntity::~MovieEntity() {
  // @@protoc_insertion_point(destructor:com.opensource.svga.MovieEntity)
  SharedDtor();
}

void MovieEntity::SharedDtor() {
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete params_;
  }
}

void MovieEntity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MovieEntity::descriptor() {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const MovieEntity& MovieEntity::default_instance() {
  protobuf_svga_2eproto::InitDefaults();
  return *internal_default_instance();
}

MovieEntity* MovieEntity::New(::google::protobuf::Arena* arena) const {
  MovieEntity* n = new MovieEntity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MovieEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:com.opensource.svga.MovieEntity)
  images_.Clear();
  sprites_.Clear();
  audios_.Clear();
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && params_ != NULL) {
    delete params_;
  }
  params_ = NULL;
}

bool MovieEntity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:com.opensource.svga.MovieEntity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "com.opensource.svga.MovieEntity.version"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .com.opensource.svga.MovieParams params = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_params()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // map<string, bytes> images = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          MovieEntity_ImagesEntry::Parser< ::google::protobuf::internal::MapField<
              MovieEntity_ImagesEntry,
              ::std::string, ::std::string,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
              0 >,
            ::google::protobuf::Map< ::std::string, ::std::string > > parser(&images_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "com.opensource.svga.MovieEntity.ImagesEntry.key"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .com.opensource.svga.SpriteEntity sprites = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sprites()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .com.opensource.svga.AudioEntity audios = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_audios()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.opensource.svga.MovieEntity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.opensource.svga.MovieEntity)
  return false;
#undef DO_
}

void MovieEntity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.opensource.svga.MovieEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string version = 1;
  if (this->version().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.MovieEntity.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->version(), output);
  }

  // .com.opensource.svga.MovieParams params = 2;
  if (this->has_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->params_, output);
  }

  // map<string, bytes> images = 3;
  if (!this->images().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "com.opensource.svga.MovieEntity.ImagesEntry.key");
      }
    };

    if (output->IsSerializationDeterministic() &&
        this->images().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->images().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::std::string >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->images().begin();
          it != this->images().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<MovieEntity_ImagesEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(images_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            3, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<MovieEntity_ImagesEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->images().begin();
          it != this->images().end(); ++it) {
        entry.reset(images_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            3, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // repeated .com.opensource.svga.SpriteEntity sprites = 4;
  for (unsigned int i = 0, n = this->sprites_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->sprites(i), output);
  }

  // repeated .com.opensource.svga.AudioEntity audios = 5;
  for (unsigned int i = 0, n = this->audios_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->audios(i), output);
  }

  // @@protoc_insertion_point(serialize_end:com.opensource.svga.MovieEntity)
}

::google::protobuf::uint8* MovieEntity::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.opensource.svga.MovieEntity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string version = 1;
  if (this->version().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "com.opensource.svga.MovieEntity.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }

  // .com.opensource.svga.MovieParams params = 2;
  if (this->has_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->params_, deterministic, target);
  }

  // map<string, bytes> images = 3;
  if (!this->images().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "com.opensource.svga.MovieEntity.ImagesEntry.key");
      }
    };

    if (deterministic &&
        this->images().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->images().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::std::string >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->images().begin();
          it != this->images().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<MovieEntity_ImagesEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(images_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       3, *entry, deterministic, target);
;
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<MovieEntity_ImagesEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
          it = this->images().begin();
          it != this->images().end(); ++it) {
        entry.reset(images_.NewEntryWrapper(
            it->first, it->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       3, *entry, deterministic, target);
;
        Utf8Check::Check(&*it);
      }
    }
  }

  // repeated .com.opensource.svga.SpriteEntity sprites = 4;
  for (unsigned int i = 0, n = this->sprites_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->sprites(i), deterministic, target);
  }

  // repeated .com.opensource.svga.AudioEntity audios = 5;
  for (unsigned int i = 0, n = this->audios_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->audios(i), deterministic, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:com.opensource.svga.MovieEntity)
  return target;
}

size_t MovieEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.opensource.svga.MovieEntity)
  size_t total_size = 0;

  // map<string, bytes> images = 3;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->images_size());
  {
    ::google::protobuf::scoped_ptr<MovieEntity_ImagesEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::std::string >::const_iterator
        it = this->images().begin();
        it != this->images().end(); ++it) {
      entry.reset(images_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  // repeated .com.opensource.svga.SpriteEntity sprites = 4;
  {
    unsigned int count = this->sprites_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sprites(i));
    }
  }

  // repeated .com.opensource.svga.AudioEntity audios = 5;
  {
    unsigned int count = this->audios_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->audios(i));
    }
  }

  // string version = 1;
  if (this->version().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->version());
  }

  // .com.opensource.svga.MovieParams params = 2;
  if (this->has_params()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->params_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MovieEntity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:com.opensource.svga.MovieEntity)
  GOOGLE_DCHECK_NE(&from, this);
  const MovieEntity* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const MovieEntity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:com.opensource.svga.MovieEntity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:com.opensource.svga.MovieEntity)
    MergeFrom(*source);
  }
}

void MovieEntity::MergeFrom(const MovieEntity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:com.opensource.svga.MovieEntity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  images_.MergeFrom(from.images_);
  sprites_.MergeFrom(from.sprites_);
  audios_.MergeFrom(from.audios_);
  if (from.version().size() > 0) {

    version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  if (from.has_params()) {
    mutable_params()->::com::opensource::svga::MovieParams::MergeFrom(from.params());
  }
}

void MovieEntity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:com.opensource.svga.MovieEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MovieEntity::CopyFrom(const MovieEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.opensource.svga.MovieEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovieEntity::IsInitialized() const {
  return true;
}

void MovieEntity::Swap(MovieEntity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MovieEntity::InternalSwap(MovieEntity* other) {
  images_.Swap(&other->images_);
  sprites_.InternalSwap(&other->sprites_);
  audios_.InternalSwap(&other->audios_);
  version_.Swap(&other->version_);
  std::swap(params_, other->params_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MovieEntity::GetMetadata() const {
  protobuf_svga_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_svga_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MovieEntity

// string version = 1;
void MovieEntity::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& MovieEntity::version() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.version)
  return version_.GetNoArena();
}
void MovieEntity::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieEntity.version)
}
#if LANG_CXX11
void MovieEntity::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.MovieEntity.version)
}
#endif
void MovieEntity::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.MovieEntity.version)
}
void MovieEntity::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.MovieEntity.version)
}
::std::string* MovieEntity::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* MovieEntity::release_version() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.MovieEntity.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void MovieEntity::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.MovieEntity.version)
}

// .com.opensource.svga.MovieParams params = 2;
bool MovieEntity::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
void MovieEntity::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) delete params_;
  params_ = NULL;
}
const ::com::opensource::svga::MovieParams& MovieEntity::params() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.params)
  return params_ != NULL ? *params_
                         : *::com::opensource::svga::MovieParams::internal_default_instance();
}
::com::opensource::svga::MovieParams* MovieEntity::mutable_params() {
  
  if (params_ == NULL) {
    params_ = new ::com::opensource::svga::MovieParams;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.params)
  return params_;
}
::com::opensource::svga::MovieParams* MovieEntity::release_params() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.MovieEntity.params)
  
  ::com::opensource::svga::MovieParams* temp = params_;
  params_ = NULL;
  return temp;
}
void MovieEntity::set_allocated_params(::com::opensource::svga::MovieParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.MovieEntity.params)
}

// map<string, bytes> images = 3;
int MovieEntity::images_size() const {
  return images_.size();
}
void MovieEntity::clear_images() {
  images_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::std::string >&
MovieEntity::images() const {
  // @@protoc_insertion_point(field_map:com.opensource.svga.MovieEntity.images)
  return images_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::std::string >*
MovieEntity::mutable_images() {
  // @@protoc_insertion_point(field_mutable_map:com.opensource.svga.MovieEntity.images)
  return images_.MutableMap();
}

// repeated .com.opensource.svga.SpriteEntity sprites = 4;
int MovieEntity::sprites_size() const {
  return sprites_.size();
}
void MovieEntity::clear_sprites() {
  sprites_.Clear();
}
const ::com::opensource::svga::SpriteEntity& MovieEntity::sprites(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.sprites)
  return sprites_.Get(index);
}
::com::opensource::svga::SpriteEntity* MovieEntity::mutable_sprites(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.sprites)
  return sprites_.Mutable(index);
}
::com::opensource::svga::SpriteEntity* MovieEntity::add_sprites() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.MovieEntity.sprites)
  return sprites_.Add();
}
::google::protobuf::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >*
MovieEntity::mutable_sprites() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.MovieEntity.sprites)
  return &sprites_;
}
const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >&
MovieEntity::sprites() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.MovieEntity.sprites)
  return sprites_;
}

// repeated .com.opensource.svga.AudioEntity audios = 5;
int MovieEntity::audios_size() const {
  return audios_.size();
}
void MovieEntity::clear_audios() {
  audios_.Clear();
}
const ::com::opensource::svga::AudioEntity& MovieEntity::audios(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.audios)
  return audios_.Get(index);
}
::com::opensource::svga::AudioEntity* MovieEntity::mutable_audios(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.audios)
  return audios_.Mutable(index);
}
::com::opensource::svga::AudioEntity* MovieEntity::add_audios() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.MovieEntity.audios)
  return audios_.Add();
}
::google::protobuf::RepeatedPtrField< ::com::opensource::svga::AudioEntity >*
MovieEntity::mutable_audios() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.MovieEntity.audios)
  return &audios_;
}
const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::AudioEntity >&
MovieEntity::audios() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.MovieEntity.audios)
  return audios_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace svga
}  // namespace opensource
}  // namespace com

// @@protoc_insertion_point(global_scope)
