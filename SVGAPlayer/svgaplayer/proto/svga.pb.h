// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: svga.proto

#ifndef PROTOBUF_svga_2eproto__INCLUDED
#define PROTOBUF_svga_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace com {
namespace opensource {
namespace svga {
class AudioEntity;
class AudioEntityDefaultTypeInternal;
extern AudioEntityDefaultTypeInternal _AudioEntity_default_instance_;
class FrameEntity;
class FrameEntityDefaultTypeInternal;
extern FrameEntityDefaultTypeInternal _FrameEntity_default_instance_;
class Layout;
class LayoutDefaultTypeInternal;
extern LayoutDefaultTypeInternal _Layout_default_instance_;
class MovieEntity;
class MovieEntityDefaultTypeInternal;
extern MovieEntityDefaultTypeInternal _MovieEntity_default_instance_;
class MovieEntity_ImagesEntry;
class MovieEntity_ImagesEntryDefaultTypeInternal;
extern MovieEntity_ImagesEntryDefaultTypeInternal _MovieEntity_ImagesEntry_default_instance_;
class MovieParams;
class MovieParamsDefaultTypeInternal;
extern MovieParamsDefaultTypeInternal _MovieParams_default_instance_;
class ShapeEntity;
class ShapeEntityDefaultTypeInternal;
extern ShapeEntityDefaultTypeInternal _ShapeEntity_default_instance_;
class ShapeEntity_EllipseArgs;
class ShapeEntity_EllipseArgsDefaultTypeInternal;
extern ShapeEntity_EllipseArgsDefaultTypeInternal _ShapeEntity_EllipseArgs_default_instance_;
class ShapeEntity_RectArgs;
class ShapeEntity_RectArgsDefaultTypeInternal;
extern ShapeEntity_RectArgsDefaultTypeInternal _ShapeEntity_RectArgs_default_instance_;
class ShapeEntity_ShapeArgs;
class ShapeEntity_ShapeArgsDefaultTypeInternal;
extern ShapeEntity_ShapeArgsDefaultTypeInternal _ShapeEntity_ShapeArgs_default_instance_;
class ShapeEntity_ShapeStyle;
class ShapeEntity_ShapeStyleDefaultTypeInternal;
extern ShapeEntity_ShapeStyleDefaultTypeInternal _ShapeEntity_ShapeStyle_default_instance_;
class ShapeEntity_ShapeStyle_RGBAColor;
class ShapeEntity_ShapeStyle_RGBAColorDefaultTypeInternal;
extern ShapeEntity_ShapeStyle_RGBAColorDefaultTypeInternal _ShapeEntity_ShapeStyle_RGBAColor_default_instance_;
class SpriteEntity;
class SpriteEntityDefaultTypeInternal;
extern SpriteEntityDefaultTypeInternal _SpriteEntity_default_instance_;
class Transform;
class TransformDefaultTypeInternal;
extern TransformDefaultTypeInternal _Transform_default_instance_;
}  // namespace svga
}  // namespace opensource
}  // namespace com

namespace com {
namespace opensource {
namespace svga {

namespace protobuf_svga_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_svga_2eproto

enum ShapeEntity_ShapeStyle_LineCap {
  ShapeEntity_ShapeStyle_LineCap_LineCap_BUTT = 0,
  ShapeEntity_ShapeStyle_LineCap_LineCap_ROUND = 1,
  ShapeEntity_ShapeStyle_LineCap_LineCap_SQUARE = 2,
  ShapeEntity_ShapeStyle_LineCap_ShapeEntity_ShapeStyle_LineCap_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ShapeEntity_ShapeStyle_LineCap_ShapeEntity_ShapeStyle_LineCap_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ShapeEntity_ShapeStyle_LineCap_IsValid(int value);
const ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle_LineCap_LineCap_MIN = ShapeEntity_ShapeStyle_LineCap_LineCap_BUTT;
const ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle_LineCap_LineCap_MAX = ShapeEntity_ShapeStyle_LineCap_LineCap_SQUARE;
const int ShapeEntity_ShapeStyle_LineCap_LineCap_ARRAYSIZE = ShapeEntity_ShapeStyle_LineCap_LineCap_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShapeEntity_ShapeStyle_LineCap_descriptor();
inline const ::std::string& ShapeEntity_ShapeStyle_LineCap_Name(ShapeEntity_ShapeStyle_LineCap value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShapeEntity_ShapeStyle_LineCap_descriptor(), value);
}
inline bool ShapeEntity_ShapeStyle_LineCap_Parse(
    const ::std::string& name, ShapeEntity_ShapeStyle_LineCap* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeEntity_ShapeStyle_LineCap>(
    ShapeEntity_ShapeStyle_LineCap_descriptor(), name, value);
}
enum ShapeEntity_ShapeStyle_LineJoin {
  ShapeEntity_ShapeStyle_LineJoin_LineJoin_MITER = 0,
  ShapeEntity_ShapeStyle_LineJoin_LineJoin_ROUND = 1,
  ShapeEntity_ShapeStyle_LineJoin_LineJoin_BEVEL = 2,
  ShapeEntity_ShapeStyle_LineJoin_ShapeEntity_ShapeStyle_LineJoin_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ShapeEntity_ShapeStyle_LineJoin_ShapeEntity_ShapeStyle_LineJoin_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ShapeEntity_ShapeStyle_LineJoin_IsValid(int value);
const ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle_LineJoin_LineJoin_MIN = ShapeEntity_ShapeStyle_LineJoin_LineJoin_MITER;
const ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle_LineJoin_LineJoin_MAX = ShapeEntity_ShapeStyle_LineJoin_LineJoin_BEVEL;
const int ShapeEntity_ShapeStyle_LineJoin_LineJoin_ARRAYSIZE = ShapeEntity_ShapeStyle_LineJoin_LineJoin_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShapeEntity_ShapeStyle_LineJoin_descriptor();
inline const ::std::string& ShapeEntity_ShapeStyle_LineJoin_Name(ShapeEntity_ShapeStyle_LineJoin value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShapeEntity_ShapeStyle_LineJoin_descriptor(), value);
}
inline bool ShapeEntity_ShapeStyle_LineJoin_Parse(
    const ::std::string& name, ShapeEntity_ShapeStyle_LineJoin* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeEntity_ShapeStyle_LineJoin>(
    ShapeEntity_ShapeStyle_LineJoin_descriptor(), name, value);
}
enum ShapeEntity_ShapeType {
  ShapeEntity_ShapeType_SHAPE = 0,
  ShapeEntity_ShapeType_RECT = 1,
  ShapeEntity_ShapeType_ELLIPSE = 2,
  ShapeEntity_ShapeType_KEEP = 3,
  ShapeEntity_ShapeType_ShapeEntity_ShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ShapeEntity_ShapeType_ShapeEntity_ShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ShapeEntity_ShapeType_IsValid(int value);
const ShapeEntity_ShapeType ShapeEntity_ShapeType_ShapeType_MIN = ShapeEntity_ShapeType_SHAPE;
const ShapeEntity_ShapeType ShapeEntity_ShapeType_ShapeType_MAX = ShapeEntity_ShapeType_KEEP;
const int ShapeEntity_ShapeType_ShapeType_ARRAYSIZE = ShapeEntity_ShapeType_ShapeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShapeEntity_ShapeType_descriptor();
inline const ::std::string& ShapeEntity_ShapeType_Name(ShapeEntity_ShapeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShapeEntity_ShapeType_descriptor(), value);
}
inline bool ShapeEntity_ShapeType_Parse(
    const ::std::string& name, ShapeEntity_ShapeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShapeEntity_ShapeType>(
    ShapeEntity_ShapeType_descriptor(), name, value);
}
// ===================================================================

class MovieParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.MovieParams) */ {
 public:
  MovieParams();
  virtual ~MovieParams();

  MovieParams(const MovieParams& from);

  inline MovieParams& operator=(const MovieParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MovieParams& default_instance();

  static inline const MovieParams* internal_default_instance() {
    return reinterpret_cast<const MovieParams*>(
               &_MovieParams_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(MovieParams* other);

  // implements Message ----------------------------------------------

  inline MovieParams* New() const PROTOBUF_FINAL { return New(NULL); }

  MovieParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MovieParams& from);
  void MergeFrom(const MovieParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MovieParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float viewBoxWidth = 1;
  void clear_viewboxwidth();
  static const int kViewBoxWidthFieldNumber = 1;
  float viewboxwidth() const;
  void set_viewboxwidth(float value);

  // float viewBoxHeight = 2;
  void clear_viewboxheight();
  static const int kViewBoxHeightFieldNumber = 2;
  float viewboxheight() const;
  void set_viewboxheight(float value);

  // int32 fps = 3;
  void clear_fps();
  static const int kFpsFieldNumber = 3;
  ::google::protobuf::int32 fps() const;
  void set_fps(::google::protobuf::int32 value);

  // int32 frames = 4;
  void clear_frames();
  static const int kFramesFieldNumber = 4;
  ::google::protobuf::int32 frames() const;
  void set_frames(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.MovieParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float viewboxwidth_;
  float viewboxheight_;
  ::google::protobuf::int32 fps_;
  ::google::protobuf::int32 frames_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpriteEntity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.SpriteEntity) */ {
 public:
  SpriteEntity();
  virtual ~SpriteEntity();

  SpriteEntity(const SpriteEntity& from);

  inline SpriteEntity& operator=(const SpriteEntity& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpriteEntity& default_instance();

  static inline const SpriteEntity* internal_default_instance() {
    return reinterpret_cast<const SpriteEntity*>(
               &_SpriteEntity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SpriteEntity* other);

  // implements Message ----------------------------------------------

  inline SpriteEntity* New() const PROTOBUF_FINAL { return New(NULL); }

  SpriteEntity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpriteEntity& from);
  void MergeFrom(const SpriteEntity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpriteEntity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.opensource.svga.FrameEntity frames = 2;
  int frames_size() const;
  void clear_frames();
  static const int kFramesFieldNumber = 2;
  const ::com::opensource::svga::FrameEntity& frames(int index) const;
  ::com::opensource::svga::FrameEntity* mutable_frames(int index);
  ::com::opensource::svga::FrameEntity* add_frames();
  ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::FrameEntity >*
      mutable_frames();
  const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::FrameEntity >&
      frames() const;

  // string imageKey = 1;
  void clear_imagekey();
  static const int kImageKeyFieldNumber = 1;
  const ::std::string& imagekey() const;
  void set_imagekey(const ::std::string& value);
  #if LANG_CXX11
  void set_imagekey(::std::string&& value);
  #endif
  void set_imagekey(const char* value);
  void set_imagekey(const char* value, size_t size);
  ::std::string* mutable_imagekey();
  ::std::string* release_imagekey();
  void set_allocated_imagekey(::std::string* imagekey);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.SpriteEntity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::FrameEntity > frames_;
  ::google::protobuf::internal::ArenaStringPtr imagekey_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AudioEntity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.AudioEntity) */ {
 public:
  AudioEntity();
  virtual ~AudioEntity();

  AudioEntity(const AudioEntity& from);

  inline AudioEntity& operator=(const AudioEntity& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioEntity& default_instance();

  static inline const AudioEntity* internal_default_instance() {
    return reinterpret_cast<const AudioEntity*>(
               &_AudioEntity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AudioEntity* other);

  // implements Message ----------------------------------------------

  inline AudioEntity* New() const PROTOBUF_FINAL { return New(NULL); }

  AudioEntity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AudioEntity& from);
  void MergeFrom(const AudioEntity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AudioEntity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string audioKey = 1;
  void clear_audiokey();
  static const int kAudioKeyFieldNumber = 1;
  const ::std::string& audiokey() const;
  void set_audiokey(const ::std::string& value);
  #if LANG_CXX11
  void set_audiokey(::std::string&& value);
  #endif
  void set_audiokey(const char* value);
  void set_audiokey(const char* value, size_t size);
  ::std::string* mutable_audiokey();
  ::std::string* release_audiokey();
  void set_allocated_audiokey(::std::string* audiokey);

  // int32 startFrame = 2;
  void clear_startframe();
  static const int kStartFrameFieldNumber = 2;
  ::google::protobuf::int32 startframe() const;
  void set_startframe(::google::protobuf::int32 value);

  // int32 endFrame = 3;
  void clear_endframe();
  static const int kEndFrameFieldNumber = 3;
  ::google::protobuf::int32 endframe() const;
  void set_endframe(::google::protobuf::int32 value);

  // int32 startTime = 4;
  void clear_starttime();
  static const int kStartTimeFieldNumber = 4;
  ::google::protobuf::int32 starttime() const;
  void set_starttime(::google::protobuf::int32 value);

  // int32 totalTime = 5;
  void clear_totaltime();
  static const int kTotalTimeFieldNumber = 5;
  ::google::protobuf::int32 totaltime() const;
  void set_totaltime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.AudioEntity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr audiokey_;
  ::google::protobuf::int32 startframe_;
  ::google::protobuf::int32 endframe_;
  ::google::protobuf::int32 starttime_;
  ::google::protobuf::int32 totaltime_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Layout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.Layout) */ {
 public:
  Layout();
  virtual ~Layout();

  Layout(const Layout& from);

  inline Layout& operator=(const Layout& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Layout& default_instance();

  static inline const Layout* internal_default_instance() {
    return reinterpret_cast<const Layout*>(
               &_Layout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Layout* other);

  // implements Message ----------------------------------------------

  inline Layout* New() const PROTOBUF_FINAL { return New(NULL); }

  Layout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Layout& from);
  void MergeFrom(const Layout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Layout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float width = 3;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  float width() const;
  void set_width(float value);

  // float height = 4;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  float height() const;
  void set_height(float value);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.Layout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float width_;
  float height_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transform : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.Transform) */ {
 public:
  Transform();
  virtual ~Transform();

  Transform(const Transform& from);

  inline Transform& operator=(const Transform& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transform& default_instance();

  static inline const Transform* internal_default_instance() {
    return reinterpret_cast<const Transform*>(
               &_Transform_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Transform* other);

  // implements Message ----------------------------------------------

  inline Transform* New() const PROTOBUF_FINAL { return New(NULL); }

  Transform* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Transform& from);
  void MergeFrom(const Transform& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Transform* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float a = 1;
  void clear_a();
  static const int kAFieldNumber = 1;
  float a() const;
  void set_a(float value);

  // float b = 2;
  void clear_b();
  static const int kBFieldNumber = 2;
  float b() const;
  void set_b(float value);

  // float c = 3;
  void clear_c();
  static const int kCFieldNumber = 3;
  float c() const;
  void set_c(float value);

  // float d = 4;
  void clear_d();
  static const int kDFieldNumber = 4;
  float d() const;
  void set_d(float value);

  // float tx = 5;
  void clear_tx();
  static const int kTxFieldNumber = 5;
  float tx() const;
  void set_tx(float value);

  // float ty = 6;
  void clear_ty();
  static const int kTyFieldNumber = 6;
  float ty() const;
  void set_ty(float value);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.Transform)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float a_;
  float b_;
  float c_;
  float d_;
  float tx_;
  float ty_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShapeEntity_ShapeArgs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.ShapeArgs) */ {
 public:
  ShapeEntity_ShapeArgs();
  virtual ~ShapeEntity_ShapeArgs();

  ShapeEntity_ShapeArgs(const ShapeEntity_ShapeArgs& from);

  inline ShapeEntity_ShapeArgs& operator=(const ShapeEntity_ShapeArgs& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeEntity_ShapeArgs& default_instance();

  static inline const ShapeEntity_ShapeArgs* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_ShapeArgs*>(
               &_ShapeEntity_ShapeArgs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ShapeEntity_ShapeArgs* other);

  // implements Message ----------------------------------------------

  inline ShapeEntity_ShapeArgs* New() const PROTOBUF_FINAL { return New(NULL); }

  ShapeEntity_ShapeArgs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ShapeEntity_ShapeArgs& from);
  void MergeFrom(const ShapeEntity_ShapeArgs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ShapeEntity_ShapeArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string d = 1;
  void clear_d();
  static const int kDFieldNumber = 1;
  const ::std::string& d() const;
  void set_d(const ::std::string& value);
  #if LANG_CXX11
  void set_d(::std::string&& value);
  #endif
  void set_d(const char* value);
  void set_d(const char* value, size_t size);
  ::std::string* mutable_d();
  ::std::string* release_d();
  void set_allocated_d(::std::string* d);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.ShapeArgs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr d_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShapeEntity_RectArgs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.RectArgs) */ {
 public:
  ShapeEntity_RectArgs();
  virtual ~ShapeEntity_RectArgs();

  ShapeEntity_RectArgs(const ShapeEntity_RectArgs& from);

  inline ShapeEntity_RectArgs& operator=(const ShapeEntity_RectArgs& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeEntity_RectArgs& default_instance();

  static inline const ShapeEntity_RectArgs* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_RectArgs*>(
               &_ShapeEntity_RectArgs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ShapeEntity_RectArgs* other);

  // implements Message ----------------------------------------------

  inline ShapeEntity_RectArgs* New() const PROTOBUF_FINAL { return New(NULL); }

  ShapeEntity_RectArgs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ShapeEntity_RectArgs& from);
  void MergeFrom(const ShapeEntity_RectArgs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ShapeEntity_RectArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float width = 3;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  float width() const;
  void set_width(float value);

  // float height = 4;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  float height() const;
  void set_height(float value);

  // float cornerRadius = 5;
  void clear_cornerradius();
  static const int kCornerRadiusFieldNumber = 5;
  float cornerradius() const;
  void set_cornerradius(float value);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.RectArgs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float width_;
  float height_;
  float cornerradius_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShapeEntity_EllipseArgs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.EllipseArgs) */ {
 public:
  ShapeEntity_EllipseArgs();
  virtual ~ShapeEntity_EllipseArgs();

  ShapeEntity_EllipseArgs(const ShapeEntity_EllipseArgs& from);

  inline ShapeEntity_EllipseArgs& operator=(const ShapeEntity_EllipseArgs& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeEntity_EllipseArgs& default_instance();

  static inline const ShapeEntity_EllipseArgs* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_EllipseArgs*>(
               &_ShapeEntity_EllipseArgs_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ShapeEntity_EllipseArgs* other);

  // implements Message ----------------------------------------------

  inline ShapeEntity_EllipseArgs* New() const PROTOBUF_FINAL { return New(NULL); }

  ShapeEntity_EllipseArgs* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ShapeEntity_EllipseArgs& from);
  void MergeFrom(const ShapeEntity_EllipseArgs& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ShapeEntity_EllipseArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float radiusX = 3;
  void clear_radiusx();
  static const int kRadiusXFieldNumber = 3;
  float radiusx() const;
  void set_radiusx(float value);

  // float radiusY = 4;
  void clear_radiusy();
  static const int kRadiusYFieldNumber = 4;
  float radiusy() const;
  void set_radiusy(float value);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.EllipseArgs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float radiusx_;
  float radiusy_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShapeEntity_ShapeStyle_RGBAColor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor) */ {
 public:
  ShapeEntity_ShapeStyle_RGBAColor();
  virtual ~ShapeEntity_ShapeStyle_RGBAColor();

  ShapeEntity_ShapeStyle_RGBAColor(const ShapeEntity_ShapeStyle_RGBAColor& from);

  inline ShapeEntity_ShapeStyle_RGBAColor& operator=(const ShapeEntity_ShapeStyle_RGBAColor& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeEntity_ShapeStyle_RGBAColor& default_instance();

  static inline const ShapeEntity_ShapeStyle_RGBAColor* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_ShapeStyle_RGBAColor*>(
               &_ShapeEntity_ShapeStyle_RGBAColor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ShapeEntity_ShapeStyle_RGBAColor* other);

  // implements Message ----------------------------------------------

  inline ShapeEntity_ShapeStyle_RGBAColor* New() const PROTOBUF_FINAL { return New(NULL); }

  ShapeEntity_ShapeStyle_RGBAColor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ShapeEntity_ShapeStyle_RGBAColor& from);
  void MergeFrom(const ShapeEntity_ShapeStyle_RGBAColor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ShapeEntity_ShapeStyle_RGBAColor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float r = 1;
  void clear_r();
  static const int kRFieldNumber = 1;
  float r() const;
  void set_r(float value);

  // float g = 2;
  void clear_g();
  static const int kGFieldNumber = 2;
  float g() const;
  void set_g(float value);

  // float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // float a = 4;
  void clear_a();
  static const int kAFieldNumber = 4;
  float a() const;
  void set_a(float value);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float r_;
  float g_;
  float b_;
  float a_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShapeEntity_ShapeStyle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity.ShapeStyle) */ {
 public:
  ShapeEntity_ShapeStyle();
  virtual ~ShapeEntity_ShapeStyle();

  ShapeEntity_ShapeStyle(const ShapeEntity_ShapeStyle& from);

  inline ShapeEntity_ShapeStyle& operator=(const ShapeEntity_ShapeStyle& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeEntity_ShapeStyle& default_instance();

  static inline const ShapeEntity_ShapeStyle* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity_ShapeStyle*>(
               &_ShapeEntity_ShapeStyle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ShapeEntity_ShapeStyle* other);

  // implements Message ----------------------------------------------

  inline ShapeEntity_ShapeStyle* New() const PROTOBUF_FINAL { return New(NULL); }

  ShapeEntity_ShapeStyle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ShapeEntity_ShapeStyle& from);
  void MergeFrom(const ShapeEntity_ShapeStyle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ShapeEntity_ShapeStyle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ShapeEntity_ShapeStyle_RGBAColor RGBAColor;

  typedef ShapeEntity_ShapeStyle_LineCap LineCap;
  static const LineCap LineCap_BUTT =
    ShapeEntity_ShapeStyle_LineCap_LineCap_BUTT;
  static const LineCap LineCap_ROUND =
    ShapeEntity_ShapeStyle_LineCap_LineCap_ROUND;
  static const LineCap LineCap_SQUARE =
    ShapeEntity_ShapeStyle_LineCap_LineCap_SQUARE;
  static inline bool LineCap_IsValid(int value) {
    return ShapeEntity_ShapeStyle_LineCap_IsValid(value);
  }
  static const LineCap LineCap_MIN =
    ShapeEntity_ShapeStyle_LineCap_LineCap_MIN;
  static const LineCap LineCap_MAX =
    ShapeEntity_ShapeStyle_LineCap_LineCap_MAX;
  static const int LineCap_ARRAYSIZE =
    ShapeEntity_ShapeStyle_LineCap_LineCap_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LineCap_descriptor() {
    return ShapeEntity_ShapeStyle_LineCap_descriptor();
  }
  static inline const ::std::string& LineCap_Name(LineCap value) {
    return ShapeEntity_ShapeStyle_LineCap_Name(value);
  }
  static inline bool LineCap_Parse(const ::std::string& name,
      LineCap* value) {
    return ShapeEntity_ShapeStyle_LineCap_Parse(name, value);
  }

  typedef ShapeEntity_ShapeStyle_LineJoin LineJoin;
  static const LineJoin LineJoin_MITER =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_MITER;
  static const LineJoin LineJoin_ROUND =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_ROUND;
  static const LineJoin LineJoin_BEVEL =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_BEVEL;
  static inline bool LineJoin_IsValid(int value) {
    return ShapeEntity_ShapeStyle_LineJoin_IsValid(value);
  }
  static const LineJoin LineJoin_MIN =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_MIN;
  static const LineJoin LineJoin_MAX =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_MAX;
  static const int LineJoin_ARRAYSIZE =
    ShapeEntity_ShapeStyle_LineJoin_LineJoin_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LineJoin_descriptor() {
    return ShapeEntity_ShapeStyle_LineJoin_descriptor();
  }
  static inline const ::std::string& LineJoin_Name(LineJoin value) {
    return ShapeEntity_ShapeStyle_LineJoin_Name(value);
  }
  static inline bool LineJoin_Parse(const ::std::string& name,
      LineJoin* value) {
    return ShapeEntity_ShapeStyle_LineJoin_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor fill = 1;
  bool has_fill() const;
  void clear_fill();
  static const int kFillFieldNumber = 1;
  const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& fill() const;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* mutable_fill();
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* release_fill();
  void set_allocated_fill(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* fill);

  // .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor stroke = 2;
  bool has_stroke() const;
  void clear_stroke();
  static const int kStrokeFieldNumber = 2;
  const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& stroke() const;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* mutable_stroke();
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* release_stroke();
  void set_allocated_stroke(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* stroke);

  // float strokeWidth = 3;
  void clear_strokewidth();
  static const int kStrokeWidthFieldNumber = 3;
  float strokewidth() const;
  void set_strokewidth(float value);

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineCap lineCap = 4;
  void clear_linecap();
  static const int kLineCapFieldNumber = 4;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap linecap() const;
  void set_linecap(::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap value);

  // .com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin lineJoin = 5;
  void clear_linejoin();
  static const int kLineJoinFieldNumber = 5;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin linejoin() const;
  void set_linejoin(::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin value);

  // float miterLimit = 6;
  void clear_miterlimit();
  static const int kMiterLimitFieldNumber = 6;
  float miterlimit() const;
  void set_miterlimit(float value);

  // float lineDashI = 7;
  void clear_linedashi();
  static const int kLineDashIFieldNumber = 7;
  float linedashi() const;
  void set_linedashi(float value);

  // float lineDashII = 8;
  void clear_linedashii();
  static const int kLineDashIIFieldNumber = 8;
  float linedashii() const;
  void set_linedashii(float value);

  // float lineDashIII = 9;
  void clear_linedashiii();
  static const int kLineDashIIIFieldNumber = 9;
  float linedashiii() const;
  void set_linedashiii(float value);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity.ShapeStyle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* fill_;
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* stroke_;
  float strokewidth_;
  int linecap_;
  int linejoin_;
  float miterlimit_;
  float linedashi_;
  float linedashii_;
  float linedashiii_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShapeEntity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.ShapeEntity) */ {
 public:
  ShapeEntity();
  virtual ~ShapeEntity();

  ShapeEntity(const ShapeEntity& from);

  inline ShapeEntity& operator=(const ShapeEntity& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeEntity& default_instance();

  enum ArgsCase {
    kShape = 2,
    kRect = 3,
    kEllipse = 4,
    ARGS_NOT_SET = 0,
  };

  static inline const ShapeEntity* internal_default_instance() {
    return reinterpret_cast<const ShapeEntity*>(
               &_ShapeEntity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ShapeEntity* other);

  // implements Message ----------------------------------------------

  inline ShapeEntity* New() const PROTOBUF_FINAL { return New(NULL); }

  ShapeEntity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ShapeEntity& from);
  void MergeFrom(const ShapeEntity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ShapeEntity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ShapeEntity_ShapeArgs ShapeArgs;
  typedef ShapeEntity_RectArgs RectArgs;
  typedef ShapeEntity_EllipseArgs EllipseArgs;
  typedef ShapeEntity_ShapeStyle ShapeStyle;

  typedef ShapeEntity_ShapeType ShapeType;
  static const ShapeType SHAPE =
    ShapeEntity_ShapeType_SHAPE;
  static const ShapeType RECT =
    ShapeEntity_ShapeType_RECT;
  static const ShapeType ELLIPSE =
    ShapeEntity_ShapeType_ELLIPSE;
  static const ShapeType KEEP =
    ShapeEntity_ShapeType_KEEP;
  static inline bool ShapeType_IsValid(int value) {
    return ShapeEntity_ShapeType_IsValid(value);
  }
  static const ShapeType ShapeType_MIN =
    ShapeEntity_ShapeType_ShapeType_MIN;
  static const ShapeType ShapeType_MAX =
    ShapeEntity_ShapeType_ShapeType_MAX;
  static const int ShapeType_ARRAYSIZE =
    ShapeEntity_ShapeType_ShapeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ShapeType_descriptor() {
    return ShapeEntity_ShapeType_descriptor();
  }
  static inline const ::std::string& ShapeType_Name(ShapeType value) {
    return ShapeEntity_ShapeType_Name(value);
  }
  static inline bool ShapeType_Parse(const ::std::string& name,
      ShapeType* value) {
    return ShapeEntity_ShapeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .com.opensource.svga.ShapeEntity.ShapeStyle styles = 10;
  bool has_styles() const;
  void clear_styles();
  static const int kStylesFieldNumber = 10;
  const ::com::opensource::svga::ShapeEntity_ShapeStyle& styles() const;
  ::com::opensource::svga::ShapeEntity_ShapeStyle* mutable_styles();
  ::com::opensource::svga::ShapeEntity_ShapeStyle* release_styles();
  void set_allocated_styles(::com::opensource::svga::ShapeEntity_ShapeStyle* styles);

  // .com.opensource.svga.Transform transform = 11;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 11;
  const ::com::opensource::svga::Transform& transform() const;
  ::com::opensource::svga::Transform* mutable_transform();
  ::com::opensource::svga::Transform* release_transform();
  void set_allocated_transform(::com::opensource::svga::Transform* transform);

  // .com.opensource.svga.ShapeEntity.ShapeType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::com::opensource::svga::ShapeEntity_ShapeType type() const;
  void set_type(::com::opensource::svga::ShapeEntity_ShapeType value);

  // .com.opensource.svga.ShapeEntity.ShapeArgs shape = 2;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 2;
  const ::com::opensource::svga::ShapeEntity_ShapeArgs& shape() const;
  ::com::opensource::svga::ShapeEntity_ShapeArgs* mutable_shape();
  ::com::opensource::svga::ShapeEntity_ShapeArgs* release_shape();
  void set_allocated_shape(::com::opensource::svga::ShapeEntity_ShapeArgs* shape);

  // .com.opensource.svga.ShapeEntity.RectArgs rect = 3;
  bool has_rect() const;
  void clear_rect();
  static const int kRectFieldNumber = 3;
  const ::com::opensource::svga::ShapeEntity_RectArgs& rect() const;
  ::com::opensource::svga::ShapeEntity_RectArgs* mutable_rect();
  ::com::opensource::svga::ShapeEntity_RectArgs* release_rect();
  void set_allocated_rect(::com::opensource::svga::ShapeEntity_RectArgs* rect);

  // .com.opensource.svga.ShapeEntity.EllipseArgs ellipse = 4;
  bool has_ellipse() const;
  void clear_ellipse();
  static const int kEllipseFieldNumber = 4;
  const ::com::opensource::svga::ShapeEntity_EllipseArgs& ellipse() const;
  ::com::opensource::svga::ShapeEntity_EllipseArgs* mutable_ellipse();
  ::com::opensource::svga::ShapeEntity_EllipseArgs* release_ellipse();
  void set_allocated_ellipse(::com::opensource::svga::ShapeEntity_EllipseArgs* ellipse);

  ArgsCase args_case() const;
  // @@protoc_insertion_point(class_scope:com.opensource.svga.ShapeEntity)
 private:
  void set_has_shape();
  void set_has_rect();
  void set_has_ellipse();

  inline bool has_args() const;
  void clear_args();
  inline void clear_has_args();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::com::opensource::svga::ShapeEntity_ShapeStyle* styles_;
  ::com::opensource::svga::Transform* transform_;
  int type_;
  union ArgsUnion {
    ArgsUnion() {}
    ::com::opensource::svga::ShapeEntity_ShapeArgs* shape_;
    ::com::opensource::svga::ShapeEntity_RectArgs* rect_;
    ::com::opensource::svga::ShapeEntity_EllipseArgs* ellipse_;
  } args_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FrameEntity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.FrameEntity) */ {
 public:
  FrameEntity();
  virtual ~FrameEntity();

  FrameEntity(const FrameEntity& from);

  inline FrameEntity& operator=(const FrameEntity& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameEntity& default_instance();

  static inline const FrameEntity* internal_default_instance() {
    return reinterpret_cast<const FrameEntity*>(
               &_FrameEntity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(FrameEntity* other);

  // implements Message ----------------------------------------------

  inline FrameEntity* New() const PROTOBUF_FINAL { return New(NULL); }

  FrameEntity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FrameEntity& from);
  void MergeFrom(const FrameEntity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FrameEntity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.opensource.svga.ShapeEntity shapes = 5;
  int shapes_size() const;
  void clear_shapes();
  static const int kShapesFieldNumber = 5;
  const ::com::opensource::svga::ShapeEntity& shapes(int index) const;
  ::com::opensource::svga::ShapeEntity* mutable_shapes(int index);
  ::com::opensource::svga::ShapeEntity* add_shapes();
  ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >*
      mutable_shapes();
  const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >&
      shapes() const;

  // string clipPath = 4;
  void clear_clippath();
  static const int kClipPathFieldNumber = 4;
  const ::std::string& clippath() const;
  void set_clippath(const ::std::string& value);
  #if LANG_CXX11
  void set_clippath(::std::string&& value);
  #endif
  void set_clippath(const char* value);
  void set_clippath(const char* value, size_t size);
  ::std::string* mutable_clippath();
  ::std::string* release_clippath();
  void set_allocated_clippath(::std::string* clippath);

  // .com.opensource.svga.Layout layout = 2;
  bool has_layout() const;
  void clear_layout();
  static const int kLayoutFieldNumber = 2;
  const ::com::opensource::svga::Layout& layout() const;
  ::com::opensource::svga::Layout* mutable_layout();
  ::com::opensource::svga::Layout* release_layout();
  void set_allocated_layout(::com::opensource::svga::Layout* layout);

  // .com.opensource.svga.Transform transform = 3;
  bool has_transform() const;
  void clear_transform();
  static const int kTransformFieldNumber = 3;
  const ::com::opensource::svga::Transform& transform() const;
  ::com::opensource::svga::Transform* mutable_transform();
  ::com::opensource::svga::Transform* release_transform();
  void set_allocated_transform(::com::opensource::svga::Transform* transform);

  // float alpha = 1;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  float alpha() const;
  void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.FrameEntity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::ShapeEntity > shapes_;
  ::google::protobuf::internal::ArenaStringPtr clippath_;
  ::com::opensource::svga::Layout* layout_;
  ::com::opensource::svga::Transform* transform_;
  float alpha_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class MovieEntity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:com.opensource.svga.MovieEntity) */ {
 public:
  MovieEntity();
  virtual ~MovieEntity();

  MovieEntity(const MovieEntity& from);

  inline MovieEntity& operator=(const MovieEntity& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MovieEntity& default_instance();

  static inline const MovieEntity* internal_default_instance() {
    return reinterpret_cast<const MovieEntity*>(
               &_MovieEntity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(MovieEntity* other);

  // implements Message ----------------------------------------------

  inline MovieEntity* New() const PROTOBUF_FINAL { return New(NULL); }

  MovieEntity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MovieEntity& from);
  void MergeFrom(const MovieEntity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MovieEntity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> images = 3;
  int images_size() const;
  void clear_images();
  static const int kImagesFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      images() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_images();

  // repeated .com.opensource.svga.SpriteEntity sprites = 4;
  int sprites_size() const;
  void clear_sprites();
  static const int kSpritesFieldNumber = 4;
  const ::com::opensource::svga::SpriteEntity& sprites(int index) const;
  ::com::opensource::svga::SpriteEntity* mutable_sprites(int index);
  ::com::opensource::svga::SpriteEntity* add_sprites();
  ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >*
      mutable_sprites();
  const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >&
      sprites() const;

  // repeated .com.opensource.svga.AudioEntity audios = 5;
  int audios_size() const;
  void clear_audios();
  static const int kAudiosFieldNumber = 5;
  const ::com::opensource::svga::AudioEntity& audios(int index) const;
  ::com::opensource::svga::AudioEntity* mutable_audios(int index);
  ::com::opensource::svga::AudioEntity* add_audios();
  ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::AudioEntity >*
      mutable_audios();
  const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::AudioEntity >&
      audios() const;

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .com.opensource.svga.MovieParams params = 2;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  const ::com::opensource::svga::MovieParams& params() const;
  ::com::opensource::svga::MovieParams* mutable_params();
  ::com::opensource::svga::MovieParams* release_params();
  void set_allocated_params(::com::opensource::svga::MovieParams* params);

  // @@protoc_insertion_point(class_scope:com.opensource.svga.MovieEntity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class MovieEntity_ImagesEntry : public ::google::protobuf::internal::MapEntry<MovieEntity_ImagesEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<MovieEntity_ImagesEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > SuperType;
    MovieEntity_ImagesEntry();
    MovieEntity_ImagesEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const MovieEntity_ImagesEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_MovieEntity_ImagesEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  ::google::protobuf::internal::MapField<
      MovieEntity_ImagesEntry,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > images_;
  private:
  ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::SpriteEntity > sprites_;
  ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::AudioEntity > audios_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::com::opensource::svga::MovieParams* params_;
  mutable int _cached_size_;
  friend struct protobuf_svga_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// MovieParams

// float viewBoxWidth = 1;
inline void MovieParams::clear_viewboxwidth() {
  viewboxwidth_ = 0;
}
inline float MovieParams::viewboxwidth() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.viewBoxWidth)
  return viewboxwidth_;
}
inline void MovieParams::set_viewboxwidth(float value) {
  
  viewboxwidth_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.viewBoxWidth)
}

// float viewBoxHeight = 2;
inline void MovieParams::clear_viewboxheight() {
  viewboxheight_ = 0;
}
inline float MovieParams::viewboxheight() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.viewBoxHeight)
  return viewboxheight_;
}
inline void MovieParams::set_viewboxheight(float value) {
  
  viewboxheight_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.viewBoxHeight)
}

// int32 fps = 3;
inline void MovieParams::clear_fps() {
  fps_ = 0;
}
inline ::google::protobuf::int32 MovieParams::fps() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.fps)
  return fps_;
}
inline void MovieParams::set_fps(::google::protobuf::int32 value) {
  
  fps_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.fps)
}

// int32 frames = 4;
inline void MovieParams::clear_frames() {
  frames_ = 0;
}
inline ::google::protobuf::int32 MovieParams::frames() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieParams.frames)
  return frames_;
}
inline void MovieParams::set_frames(::google::protobuf::int32 value) {
  
  frames_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieParams.frames)
}

// -------------------------------------------------------------------

// SpriteEntity

// string imageKey = 1;
inline void SpriteEntity::clear_imagekey() {
  imagekey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpriteEntity::imagekey() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.SpriteEntity.imageKey)
  return imagekey_.GetNoArena();
}
inline void SpriteEntity::set_imagekey(const ::std::string& value) {
  
  imagekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.SpriteEntity.imageKey)
}
#if LANG_CXX11
inline void SpriteEntity::set_imagekey(::std::string&& value) {
  
  imagekey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.SpriteEntity.imageKey)
}
#endif
inline void SpriteEntity::set_imagekey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  imagekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.SpriteEntity.imageKey)
}
inline void SpriteEntity::set_imagekey(const char* value, size_t size) {
  
  imagekey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.SpriteEntity.imageKey)
}
inline ::std::string* SpriteEntity::mutable_imagekey() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.SpriteEntity.imageKey)
  return imagekey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpriteEntity::release_imagekey() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.SpriteEntity.imageKey)
  
  return imagekey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpriteEntity::set_allocated_imagekey(::std::string* imagekey) {
  if (imagekey != NULL) {
    
  } else {
    
  }
  imagekey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imagekey);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.SpriteEntity.imageKey)
}

// repeated .com.opensource.svga.FrameEntity frames = 2;
inline int SpriteEntity::frames_size() const {
  return frames_.size();
}
inline void SpriteEntity::clear_frames() {
  frames_.Clear();
}
inline const ::com::opensource::svga::FrameEntity& SpriteEntity::frames(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.SpriteEntity.frames)
  return frames_.Get(index);
}
inline ::com::opensource::svga::FrameEntity* SpriteEntity::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.SpriteEntity.frames)
  return frames_.Mutable(index);
}
inline ::com::opensource::svga::FrameEntity* SpriteEntity::add_frames() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.SpriteEntity.frames)
  return frames_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::FrameEntity >*
SpriteEntity::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.SpriteEntity.frames)
  return &frames_;
}
inline const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::FrameEntity >&
SpriteEntity::frames() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.SpriteEntity.frames)
  return frames_;
}

// -------------------------------------------------------------------

// AudioEntity

// string audioKey = 1;
inline void AudioEntity::clear_audiokey() {
  audiokey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AudioEntity::audiokey() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.audioKey)
  return audiokey_.GetNoArena();
}
inline void AudioEntity::set_audiokey(const ::std::string& value) {
  
  audiokey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.audioKey)
}
#if LANG_CXX11
inline void AudioEntity::set_audiokey(::std::string&& value) {
  
  audiokey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.AudioEntity.audioKey)
}
#endif
inline void AudioEntity::set_audiokey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  audiokey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.AudioEntity.audioKey)
}
inline void AudioEntity::set_audiokey(const char* value, size_t size) {
  
  audiokey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.AudioEntity.audioKey)
}
inline ::std::string* AudioEntity::mutable_audiokey() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.AudioEntity.audioKey)
  return audiokey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioEntity::release_audiokey() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.AudioEntity.audioKey)
  
  return audiokey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioEntity::set_allocated_audiokey(::std::string* audiokey) {
  if (audiokey != NULL) {
    
  } else {
    
  }
  audiokey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), audiokey);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.AudioEntity.audioKey)
}

// int32 startFrame = 2;
inline void AudioEntity::clear_startframe() {
  startframe_ = 0;
}
inline ::google::protobuf::int32 AudioEntity::startframe() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.startFrame)
  return startframe_;
}
inline void AudioEntity::set_startframe(::google::protobuf::int32 value) {
  
  startframe_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.startFrame)
}

// int32 endFrame = 3;
inline void AudioEntity::clear_endframe() {
  endframe_ = 0;
}
inline ::google::protobuf::int32 AudioEntity::endframe() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.endFrame)
  return endframe_;
}
inline void AudioEntity::set_endframe(::google::protobuf::int32 value) {
  
  endframe_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.endFrame)
}

// int32 startTime = 4;
inline void AudioEntity::clear_starttime() {
  starttime_ = 0;
}
inline ::google::protobuf::int32 AudioEntity::starttime() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.startTime)
  return starttime_;
}
inline void AudioEntity::set_starttime(::google::protobuf::int32 value) {
  
  starttime_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.startTime)
}

// int32 totalTime = 5;
inline void AudioEntity::clear_totaltime() {
  totaltime_ = 0;
}
inline ::google::protobuf::int32 AudioEntity::totaltime() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.AudioEntity.totalTime)
  return totaltime_;
}
inline void AudioEntity::set_totaltime(::google::protobuf::int32 value) {
  
  totaltime_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.AudioEntity.totalTime)
}

// -------------------------------------------------------------------

// Layout

// float x = 1;
inline void Layout::clear_x() {
  x_ = 0;
}
inline float Layout::x() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.x)
  return x_;
}
inline void Layout::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.x)
}

// float y = 2;
inline void Layout::clear_y() {
  y_ = 0;
}
inline float Layout::y() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.y)
  return y_;
}
inline void Layout::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.y)
}

// float width = 3;
inline void Layout::clear_width() {
  width_ = 0;
}
inline float Layout::width() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.width)
  return width_;
}
inline void Layout::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.width)
}

// float height = 4;
inline void Layout::clear_height() {
  height_ = 0;
}
inline float Layout::height() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Layout.height)
  return height_;
}
inline void Layout::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Layout.height)
}

// -------------------------------------------------------------------

// Transform

// float a = 1;
inline void Transform::clear_a() {
  a_ = 0;
}
inline float Transform::a() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.a)
  return a_;
}
inline void Transform::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.a)
}

// float b = 2;
inline void Transform::clear_b() {
  b_ = 0;
}
inline float Transform::b() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.b)
  return b_;
}
inline void Transform::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.b)
}

// float c = 3;
inline void Transform::clear_c() {
  c_ = 0;
}
inline float Transform::c() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.c)
  return c_;
}
inline void Transform::set_c(float value) {
  
  c_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.c)
}

// float d = 4;
inline void Transform::clear_d() {
  d_ = 0;
}
inline float Transform::d() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.d)
  return d_;
}
inline void Transform::set_d(float value) {
  
  d_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.d)
}

// float tx = 5;
inline void Transform::clear_tx() {
  tx_ = 0;
}
inline float Transform::tx() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.tx)
  return tx_;
}
inline void Transform::set_tx(float value) {
  
  tx_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.tx)
}

// float ty = 6;
inline void Transform::clear_ty() {
  ty_ = 0;
}
inline float Transform::ty() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.Transform.ty)
  return ty_;
}
inline void Transform::set_ty(float value) {
  
  ty_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.Transform.ty)
}

// -------------------------------------------------------------------

// ShapeEntity_ShapeArgs

// string d = 1;
inline void ShapeEntity_ShapeArgs::clear_d() {
  d_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ShapeEntity_ShapeArgs::d() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeArgs.d)
  return d_.GetNoArena();
}
inline void ShapeEntity_ShapeArgs::set_d(const ::std::string& value) {
  
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
#if LANG_CXX11
inline void ShapeEntity_ShapeArgs::set_d(::std::string&& value) {
  
  d_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
#endif
inline void ShapeEntity_ShapeArgs::set_d(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
inline void ShapeEntity_ShapeArgs::set_d(const char* value, size_t size) {
  
  d_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}
inline ::std::string* ShapeEntity_ShapeArgs::mutable_d() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ShapeArgs.d)
  return d_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShapeEntity_ShapeArgs::release_d() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ShapeArgs.d)
  
  return d_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShapeEntity_ShapeArgs::set_allocated_d(::std::string* d) {
  if (d != NULL) {
    
  } else {
    
  }
  d_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), d);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ShapeArgs.d)
}

// -------------------------------------------------------------------

// ShapeEntity_RectArgs

// float x = 1;
inline void ShapeEntity_RectArgs::clear_x() {
  x_ = 0;
}
inline float ShapeEntity_RectArgs::x() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.x)
  return x_;
}
inline void ShapeEntity_RectArgs::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.x)
}

// float y = 2;
inline void ShapeEntity_RectArgs::clear_y() {
  y_ = 0;
}
inline float ShapeEntity_RectArgs::y() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.y)
  return y_;
}
inline void ShapeEntity_RectArgs::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.y)
}

// float width = 3;
inline void ShapeEntity_RectArgs::clear_width() {
  width_ = 0;
}
inline float ShapeEntity_RectArgs::width() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.width)
  return width_;
}
inline void ShapeEntity_RectArgs::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.width)
}

// float height = 4;
inline void ShapeEntity_RectArgs::clear_height() {
  height_ = 0;
}
inline float ShapeEntity_RectArgs::height() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.height)
  return height_;
}
inline void ShapeEntity_RectArgs::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.height)
}

// float cornerRadius = 5;
inline void ShapeEntity_RectArgs::clear_cornerradius() {
  cornerradius_ = 0;
}
inline float ShapeEntity_RectArgs::cornerradius() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.RectArgs.cornerRadius)
  return cornerradius_;
}
inline void ShapeEntity_RectArgs::set_cornerradius(float value) {
  
  cornerradius_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.RectArgs.cornerRadius)
}

// -------------------------------------------------------------------

// ShapeEntity_EllipseArgs

// float x = 1;
inline void ShapeEntity_EllipseArgs::clear_x() {
  x_ = 0;
}
inline float ShapeEntity_EllipseArgs::x() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.x)
  return x_;
}
inline void ShapeEntity_EllipseArgs::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.x)
}

// float y = 2;
inline void ShapeEntity_EllipseArgs::clear_y() {
  y_ = 0;
}
inline float ShapeEntity_EllipseArgs::y() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.y)
  return y_;
}
inline void ShapeEntity_EllipseArgs::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.y)
}

// float radiusX = 3;
inline void ShapeEntity_EllipseArgs::clear_radiusx() {
  radiusx_ = 0;
}
inline float ShapeEntity_EllipseArgs::radiusx() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.radiusX)
  return radiusx_;
}
inline void ShapeEntity_EllipseArgs::set_radiusx(float value) {
  
  radiusx_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.radiusX)
}

// float radiusY = 4;
inline void ShapeEntity_EllipseArgs::clear_radiusy() {
  radiusy_ = 0;
}
inline float ShapeEntity_EllipseArgs::radiusy() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.EllipseArgs.radiusY)
  return radiusy_;
}
inline void ShapeEntity_EllipseArgs::set_radiusy(float value) {
  
  radiusy_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.EllipseArgs.radiusY)
}

// -------------------------------------------------------------------

// ShapeEntity_ShapeStyle_RGBAColor

// float r = 1;
inline void ShapeEntity_ShapeStyle_RGBAColor::clear_r() {
  r_ = 0;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::r() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.r)
  return r_;
}
inline void ShapeEntity_ShapeStyle_RGBAColor::set_r(float value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.r)
}

// float g = 2;
inline void ShapeEntity_ShapeStyle_RGBAColor::clear_g() {
  g_ = 0;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::g() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.g)
  return g_;
}
inline void ShapeEntity_ShapeStyle_RGBAColor::set_g(float value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.g)
}

// float b = 3;
inline void ShapeEntity_ShapeStyle_RGBAColor::clear_b() {
  b_ = 0;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::b() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.b)
  return b_;
}
inline void ShapeEntity_ShapeStyle_RGBAColor::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.b)
}

// float a = 4;
inline void ShapeEntity_ShapeStyle_RGBAColor::clear_a() {
  a_ = 0;
}
inline float ShapeEntity_ShapeStyle_RGBAColor::a() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.a)
  return a_;
}
inline void ShapeEntity_ShapeStyle_RGBAColor::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor.a)
}

// -------------------------------------------------------------------

// ShapeEntity_ShapeStyle

// .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor fill = 1;
inline bool ShapeEntity_ShapeStyle::has_fill() const {
  return this != internal_default_instance() && fill_ != NULL;
}
inline void ShapeEntity_ShapeStyle::clear_fill() {
  if (GetArenaNoVirtual() == NULL && fill_ != NULL) delete fill_;
  fill_ = NULL;
}
inline const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& ShapeEntity_ShapeStyle::fill() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
  return fill_ != NULL ? *fill_
                         : *::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor::internal_default_instance();
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::mutable_fill() {
  
  if (fill_ == NULL) {
    fill_ = new ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
  return fill_;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::release_fill() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* temp = fill_;
  fill_ = NULL;
  return temp;
}
inline void ShapeEntity_ShapeStyle::set_allocated_fill(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* fill) {
  delete fill_;
  fill_ = fill;
  if (fill) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ShapeStyle.fill)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle.RGBAColor stroke = 2;
inline bool ShapeEntity_ShapeStyle::has_stroke() const {
  return this != internal_default_instance() && stroke_ != NULL;
}
inline void ShapeEntity_ShapeStyle::clear_stroke() {
  if (GetArenaNoVirtual() == NULL && stroke_ != NULL) delete stroke_;
  stroke_ = NULL;
}
inline const ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor& ShapeEntity_ShapeStyle::stroke() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
  return stroke_ != NULL ? *stroke_
                         : *::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor::internal_default_instance();
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::mutable_stroke() {
  
  if (stroke_ == NULL) {
    stroke_ = new ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
  return stroke_;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* ShapeEntity_ShapeStyle::release_stroke() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* temp = stroke_;
  stroke_ = NULL;
  return temp;
}
inline void ShapeEntity_ShapeStyle::set_allocated_stroke(::com::opensource::svga::ShapeEntity_ShapeStyle_RGBAColor* stroke) {
  delete stroke_;
  stroke_ = stroke;
  if (stroke) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ShapeStyle.stroke)
}

// float strokeWidth = 3;
inline void ShapeEntity_ShapeStyle::clear_strokewidth() {
  strokewidth_ = 0;
}
inline float ShapeEntity_ShapeStyle::strokewidth() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.strokeWidth)
  return strokewidth_;
}
inline void ShapeEntity_ShapeStyle::set_strokewidth(float value) {
  
  strokewidth_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.strokeWidth)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle.LineCap lineCap = 4;
inline void ShapeEntity_ShapeStyle::clear_linecap() {
  linecap_ = 0;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap ShapeEntity_ShapeStyle::linecap() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineCap)
  return static_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap >(linecap_);
}
inline void ShapeEntity_ShapeStyle::set_linecap(::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap value) {
  
  linecap_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineCap)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle.LineJoin lineJoin = 5;
inline void ShapeEntity_ShapeStyle::clear_linejoin() {
  linejoin_ = 0;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin ShapeEntity_ShapeStyle::linejoin() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineJoin)
  return static_cast< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin >(linejoin_);
}
inline void ShapeEntity_ShapeStyle::set_linejoin(::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin value) {
  
  linejoin_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineJoin)
}

// float miterLimit = 6;
inline void ShapeEntity_ShapeStyle::clear_miterlimit() {
  miterlimit_ = 0;
}
inline float ShapeEntity_ShapeStyle::miterlimit() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.miterLimit)
  return miterlimit_;
}
inline void ShapeEntity_ShapeStyle::set_miterlimit(float value) {
  
  miterlimit_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.miterLimit)
}

// float lineDashI = 7;
inline void ShapeEntity_ShapeStyle::clear_linedashi() {
  linedashi_ = 0;
}
inline float ShapeEntity_ShapeStyle::linedashi() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashI)
  return linedashi_;
}
inline void ShapeEntity_ShapeStyle::set_linedashi(float value) {
  
  linedashi_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashI)
}

// float lineDashII = 8;
inline void ShapeEntity_ShapeStyle::clear_linedashii() {
  linedashii_ = 0;
}
inline float ShapeEntity_ShapeStyle::linedashii() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashII)
  return linedashii_;
}
inline void ShapeEntity_ShapeStyle::set_linedashii(float value) {
  
  linedashii_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashII)
}

// float lineDashIII = 9;
inline void ShapeEntity_ShapeStyle::clear_linedashiii() {
  linedashiii_ = 0;
}
inline float ShapeEntity_ShapeStyle::linedashiii() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashIII)
  return linedashiii_;
}
inline void ShapeEntity_ShapeStyle::set_linedashiii(float value) {
  
  linedashiii_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.ShapeStyle.lineDashIII)
}

// -------------------------------------------------------------------

// ShapeEntity

// .com.opensource.svga.ShapeEntity.ShapeType type = 1;
inline void ShapeEntity::clear_type() {
  type_ = 0;
}
inline ::com::opensource::svga::ShapeEntity_ShapeType ShapeEntity::type() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.type)
  return static_cast< ::com::opensource::svga::ShapeEntity_ShapeType >(type_);
}
inline void ShapeEntity::set_type(::com::opensource::svga::ShapeEntity_ShapeType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.ShapeEntity.type)
}

// .com.opensource.svga.ShapeEntity.ShapeArgs shape = 2;
inline bool ShapeEntity::has_shape() const {
  return args_case() == kShape;
}
inline void ShapeEntity::set_has_shape() {
  _oneof_case_[0] = kShape;
}
inline void ShapeEntity::clear_shape() {
  if (has_shape()) {
    delete args_.shape_;
    clear_has_args();
  }
}
inline  const ::com::opensource::svga::ShapeEntity_ShapeArgs& ShapeEntity::shape() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.shape)
  return has_shape()
      ? *args_.shape_
      : ::com::opensource::svga::ShapeEntity_ShapeArgs::default_instance();
}
inline ::com::opensource::svga::ShapeEntity_ShapeArgs* ShapeEntity::mutable_shape() {
  if (!has_shape()) {
    clear_args();
    set_has_shape();
    args_.shape_ = new ::com::opensource::svga::ShapeEntity_ShapeArgs;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.shape)
  return args_.shape_;
}
inline ::com::opensource::svga::ShapeEntity_ShapeArgs* ShapeEntity::release_shape() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.shape)
  if (has_shape()) {
    clear_has_args();
    ::com::opensource::svga::ShapeEntity_ShapeArgs* temp = args_.shape_;
    args_.shape_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ShapeEntity::set_allocated_shape(::com::opensource::svga::ShapeEntity_ShapeArgs* shape) {
  clear_args();
  if (shape) {
    set_has_shape();
    args_.shape_ = shape;
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.shape)
}

// .com.opensource.svga.ShapeEntity.RectArgs rect = 3;
inline bool ShapeEntity::has_rect() const {
  return args_case() == kRect;
}
inline void ShapeEntity::set_has_rect() {
  _oneof_case_[0] = kRect;
}
inline void ShapeEntity::clear_rect() {
  if (has_rect()) {
    delete args_.rect_;
    clear_has_args();
  }
}
inline  const ::com::opensource::svga::ShapeEntity_RectArgs& ShapeEntity::rect() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.rect)
  return has_rect()
      ? *args_.rect_
      : ::com::opensource::svga::ShapeEntity_RectArgs::default_instance();
}
inline ::com::opensource::svga::ShapeEntity_RectArgs* ShapeEntity::mutable_rect() {
  if (!has_rect()) {
    clear_args();
    set_has_rect();
    args_.rect_ = new ::com::opensource::svga::ShapeEntity_RectArgs;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.rect)
  return args_.rect_;
}
inline ::com::opensource::svga::ShapeEntity_RectArgs* ShapeEntity::release_rect() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.rect)
  if (has_rect()) {
    clear_has_args();
    ::com::opensource::svga::ShapeEntity_RectArgs* temp = args_.rect_;
    args_.rect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ShapeEntity::set_allocated_rect(::com::opensource::svga::ShapeEntity_RectArgs* rect) {
  clear_args();
  if (rect) {
    set_has_rect();
    args_.rect_ = rect;
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.rect)
}

// .com.opensource.svga.ShapeEntity.EllipseArgs ellipse = 4;
inline bool ShapeEntity::has_ellipse() const {
  return args_case() == kEllipse;
}
inline void ShapeEntity::set_has_ellipse() {
  _oneof_case_[0] = kEllipse;
}
inline void ShapeEntity::clear_ellipse() {
  if (has_ellipse()) {
    delete args_.ellipse_;
    clear_has_args();
  }
}
inline  const ::com::opensource::svga::ShapeEntity_EllipseArgs& ShapeEntity::ellipse() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.ellipse)
  return has_ellipse()
      ? *args_.ellipse_
      : ::com::opensource::svga::ShapeEntity_EllipseArgs::default_instance();
}
inline ::com::opensource::svga::ShapeEntity_EllipseArgs* ShapeEntity::mutable_ellipse() {
  if (!has_ellipse()) {
    clear_args();
    set_has_ellipse();
    args_.ellipse_ = new ::com::opensource::svga::ShapeEntity_EllipseArgs;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.ellipse)
  return args_.ellipse_;
}
inline ::com::opensource::svga::ShapeEntity_EllipseArgs* ShapeEntity::release_ellipse() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.ellipse)
  if (has_ellipse()) {
    clear_has_args();
    ::com::opensource::svga::ShapeEntity_EllipseArgs* temp = args_.ellipse_;
    args_.ellipse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ShapeEntity::set_allocated_ellipse(::com::opensource::svga::ShapeEntity_EllipseArgs* ellipse) {
  clear_args();
  if (ellipse) {
    set_has_ellipse();
    args_.ellipse_ = ellipse;
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.ellipse)
}

// .com.opensource.svga.ShapeEntity.ShapeStyle styles = 10;
inline bool ShapeEntity::has_styles() const {
  return this != internal_default_instance() && styles_ != NULL;
}
inline void ShapeEntity::clear_styles() {
  if (GetArenaNoVirtual() == NULL && styles_ != NULL) delete styles_;
  styles_ = NULL;
}
inline const ::com::opensource::svga::ShapeEntity_ShapeStyle& ShapeEntity::styles() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.styles)
  return styles_ != NULL ? *styles_
                         : *::com::opensource::svga::ShapeEntity_ShapeStyle::internal_default_instance();
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle* ShapeEntity::mutable_styles() {
  
  if (styles_ == NULL) {
    styles_ = new ::com::opensource::svga::ShapeEntity_ShapeStyle;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.styles)
  return styles_;
}
inline ::com::opensource::svga::ShapeEntity_ShapeStyle* ShapeEntity::release_styles() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.styles)
  
  ::com::opensource::svga::ShapeEntity_ShapeStyle* temp = styles_;
  styles_ = NULL;
  return temp;
}
inline void ShapeEntity::set_allocated_styles(::com::opensource::svga::ShapeEntity_ShapeStyle* styles) {
  delete styles_;
  styles_ = styles;
  if (styles) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.styles)
}

// .com.opensource.svga.Transform transform = 11;
inline bool ShapeEntity::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline void ShapeEntity::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) delete transform_;
  transform_ = NULL;
}
inline const ::com::opensource::svga::Transform& ShapeEntity::transform() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.ShapeEntity.transform)
  return transform_ != NULL ? *transform_
                         : *::com::opensource::svga::Transform::internal_default_instance();
}
inline ::com::opensource::svga::Transform* ShapeEntity::mutable_transform() {
  
  if (transform_ == NULL) {
    transform_ = new ::com::opensource::svga::Transform;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.ShapeEntity.transform)
  return transform_;
}
inline ::com::opensource::svga::Transform* ShapeEntity::release_transform() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.ShapeEntity.transform)
  
  ::com::opensource::svga::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void ShapeEntity::set_allocated_transform(::com::opensource::svga::Transform* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.ShapeEntity.transform)
}

inline bool ShapeEntity::has_args() const {
  return args_case() != ARGS_NOT_SET;
}
inline void ShapeEntity::clear_has_args() {
  _oneof_case_[0] = ARGS_NOT_SET;
}
inline ShapeEntity::ArgsCase ShapeEntity::args_case() const {
  return ShapeEntity::ArgsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FrameEntity

// float alpha = 1;
inline void FrameEntity::clear_alpha() {
  alpha_ = 0;
}
inline float FrameEntity::alpha() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.alpha)
  return alpha_;
}
inline void FrameEntity::set_alpha(float value) {
  
  alpha_ = value;
  // @@protoc_insertion_point(field_set:com.opensource.svga.FrameEntity.alpha)
}

// .com.opensource.svga.Layout layout = 2;
inline bool FrameEntity::has_layout() const {
  return this != internal_default_instance() && layout_ != NULL;
}
inline void FrameEntity::clear_layout() {
  if (GetArenaNoVirtual() == NULL && layout_ != NULL) delete layout_;
  layout_ = NULL;
}
inline const ::com::opensource::svga::Layout& FrameEntity::layout() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.layout)
  return layout_ != NULL ? *layout_
                         : *::com::opensource::svga::Layout::internal_default_instance();
}
inline ::com::opensource::svga::Layout* FrameEntity::mutable_layout() {
  
  if (layout_ == NULL) {
    layout_ = new ::com::opensource::svga::Layout;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.layout)
  return layout_;
}
inline ::com::opensource::svga::Layout* FrameEntity::release_layout() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.FrameEntity.layout)
  
  ::com::opensource::svga::Layout* temp = layout_;
  layout_ = NULL;
  return temp;
}
inline void FrameEntity::set_allocated_layout(::com::opensource::svga::Layout* layout) {
  delete layout_;
  layout_ = layout;
  if (layout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.FrameEntity.layout)
}

// .com.opensource.svga.Transform transform = 3;
inline bool FrameEntity::has_transform() const {
  return this != internal_default_instance() && transform_ != NULL;
}
inline void FrameEntity::clear_transform() {
  if (GetArenaNoVirtual() == NULL && transform_ != NULL) delete transform_;
  transform_ = NULL;
}
inline const ::com::opensource::svga::Transform& FrameEntity::transform() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.transform)
  return transform_ != NULL ? *transform_
                         : *::com::opensource::svga::Transform::internal_default_instance();
}
inline ::com::opensource::svga::Transform* FrameEntity::mutable_transform() {
  
  if (transform_ == NULL) {
    transform_ = new ::com::opensource::svga::Transform;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.transform)
  return transform_;
}
inline ::com::opensource::svga::Transform* FrameEntity::release_transform() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.FrameEntity.transform)
  
  ::com::opensource::svga::Transform* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void FrameEntity::set_allocated_transform(::com::opensource::svga::Transform* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.FrameEntity.transform)
}

// string clipPath = 4;
inline void FrameEntity::clear_clippath() {
  clippath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FrameEntity::clippath() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.clipPath)
  return clippath_.GetNoArena();
}
inline void FrameEntity::set_clippath(const ::std::string& value) {
  
  clippath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.FrameEntity.clipPath)
}
#if LANG_CXX11
inline void FrameEntity::set_clippath(::std::string&& value) {
  
  clippath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.FrameEntity.clipPath)
}
#endif
inline void FrameEntity::set_clippath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clippath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.FrameEntity.clipPath)
}
inline void FrameEntity::set_clippath(const char* value, size_t size) {
  
  clippath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.FrameEntity.clipPath)
}
inline ::std::string* FrameEntity::mutable_clippath() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.clipPath)
  return clippath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FrameEntity::release_clippath() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.FrameEntity.clipPath)
  
  return clippath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FrameEntity::set_allocated_clippath(::std::string* clippath) {
  if (clippath != NULL) {
    
  } else {
    
  }
  clippath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clippath);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.FrameEntity.clipPath)
}

// repeated .com.opensource.svga.ShapeEntity shapes = 5;
inline int FrameEntity::shapes_size() const {
  return shapes_.size();
}
inline void FrameEntity::clear_shapes() {
  shapes_.Clear();
}
inline const ::com::opensource::svga::ShapeEntity& FrameEntity::shapes(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.FrameEntity.shapes)
  return shapes_.Get(index);
}
inline ::com::opensource::svga::ShapeEntity* FrameEntity::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.FrameEntity.shapes)
  return shapes_.Mutable(index);
}
inline ::com::opensource::svga::ShapeEntity* FrameEntity::add_shapes() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.FrameEntity.shapes)
  return shapes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >*
FrameEntity::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.FrameEntity.shapes)
  return &shapes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::ShapeEntity >&
FrameEntity::shapes() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.FrameEntity.shapes)
  return shapes_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MovieEntity

// string version = 1;
inline void MovieEntity::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MovieEntity::version() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.version)
  return version_.GetNoArena();
}
inline void MovieEntity::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:com.opensource.svga.MovieEntity.version)
}
#if LANG_CXX11
inline void MovieEntity::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:com.opensource.svga.MovieEntity.version)
}
#endif
inline void MovieEntity::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:com.opensource.svga.MovieEntity.version)
}
inline void MovieEntity::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:com.opensource.svga.MovieEntity.version)
}
inline ::std::string* MovieEntity::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MovieEntity::release_version() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.MovieEntity.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MovieEntity::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.MovieEntity.version)
}

// .com.opensource.svga.MovieParams params = 2;
inline bool MovieEntity::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void MovieEntity::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) delete params_;
  params_ = NULL;
}
inline const ::com::opensource::svga::MovieParams& MovieEntity::params() const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.params)
  return params_ != NULL ? *params_
                         : *::com::opensource::svga::MovieParams::internal_default_instance();
}
inline ::com::opensource::svga::MovieParams* MovieEntity::mutable_params() {
  
  if (params_ == NULL) {
    params_ = new ::com::opensource::svga::MovieParams;
  }
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.params)
  return params_;
}
inline ::com::opensource::svga::MovieParams* MovieEntity::release_params() {
  // @@protoc_insertion_point(field_release:com.opensource.svga.MovieEntity.params)
  
  ::com::opensource::svga::MovieParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline void MovieEntity::set_allocated_params(::com::opensource::svga::MovieParams* params) {
  delete params_;
  params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:com.opensource.svga.MovieEntity.params)
}

// map<string, bytes> images = 3;
inline int MovieEntity::images_size() const {
  return images_.size();
}
inline void MovieEntity::clear_images() {
  images_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
MovieEntity::images() const {
  // @@protoc_insertion_point(field_map:com.opensource.svga.MovieEntity.images)
  return images_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
MovieEntity::mutable_images() {
  // @@protoc_insertion_point(field_mutable_map:com.opensource.svga.MovieEntity.images)
  return images_.MutableMap();
}

// repeated .com.opensource.svga.SpriteEntity sprites = 4;
inline int MovieEntity::sprites_size() const {
  return sprites_.size();
}
inline void MovieEntity::clear_sprites() {
  sprites_.Clear();
}
inline const ::com::opensource::svga::SpriteEntity& MovieEntity::sprites(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.sprites)
  return sprites_.Get(index);
}
inline ::com::opensource::svga::SpriteEntity* MovieEntity::mutable_sprites(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.sprites)
  return sprites_.Mutable(index);
}
inline ::com::opensource::svga::SpriteEntity* MovieEntity::add_sprites() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.MovieEntity.sprites)
  return sprites_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >*
MovieEntity::mutable_sprites() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.MovieEntity.sprites)
  return &sprites_;
}
inline const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::SpriteEntity >&
MovieEntity::sprites() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.MovieEntity.sprites)
  return sprites_;
}

// repeated .com.opensource.svga.AudioEntity audios = 5;
inline int MovieEntity::audios_size() const {
  return audios_.size();
}
inline void MovieEntity::clear_audios() {
  audios_.Clear();
}
inline const ::com::opensource::svga::AudioEntity& MovieEntity::audios(int index) const {
  // @@protoc_insertion_point(field_get:com.opensource.svga.MovieEntity.audios)
  return audios_.Get(index);
}
inline ::com::opensource::svga::AudioEntity* MovieEntity::mutable_audios(int index) {
  // @@protoc_insertion_point(field_mutable:com.opensource.svga.MovieEntity.audios)
  return audios_.Mutable(index);
}
inline ::com::opensource::svga::AudioEntity* MovieEntity::add_audios() {
  // @@protoc_insertion_point(field_add:com.opensource.svga.MovieEntity.audios)
  return audios_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::AudioEntity >*
MovieEntity::mutable_audios() {
  // @@protoc_insertion_point(field_mutable_list:com.opensource.svga.MovieEntity.audios)
  return &audios_;
}
inline const ::google::protobuf::RepeatedPtrField< ::com::opensource::svga::AudioEntity >&
MovieEntity::audios() const {
  // @@protoc_insertion_point(field_list:com.opensource.svga.MovieEntity.audios)
  return audios_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace svga
}  // namespace opensource
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap>() {
  return ::com::opensource::svga::ShapeEntity_ShapeStyle_LineCap_descriptor();
}
template <> struct is_proto_enum< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin>() {
  return ::com::opensource::svga::ShapeEntity_ShapeStyle_LineJoin_descriptor();
}
template <> struct is_proto_enum< ::com::opensource::svga::ShapeEntity_ShapeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::opensource::svga::ShapeEntity_ShapeType>() {
  return ::com::opensource::svga::ShapeEntity_ShapeType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_svga_2eproto__INCLUDED
